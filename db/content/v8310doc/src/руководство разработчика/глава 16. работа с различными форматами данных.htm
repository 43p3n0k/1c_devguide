<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=Windows-1251">
		<title>&#1043;&#1083;&#1072;&#1074;&#1072; 16. &#1056;&#1072;&#1073;&#1086;&#1090;&#1072; &#1089; &#1088;&#1072;&#1079;&#1083;&#1080;&#1095;&#1085;&#1099;&#1084;&#1080; &#1092;&#1086;&#1088;&#1084;&#1072;&#1090;&#1072;&#1084;&#1080; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093;</title>
		<LINK REL="stylesheet" href="style.css?_=1496848987">
		<SCRIPT src="script.js?_=1496848987" TYPE="text/javascript"></script>		<!--[if !IE]>--><SCRIPT src="zeroclipboard.js?_=1496848987" TYPE="text/javascript"></script><!--<![endif]-->
	<meta name="robots" content="noarchive">
<meta name="googlebot" content="noarchive">
<link href="/db/content/v8310doc/src/руководство разработчика/глава 16. работа с различными форматами данных.htm" rel="canonical">
<link href="/static/its.content.css?_=1490872753" type="text/css" rel="stylesheet">
<script type="text/javascript" src="/static/its.content.js?_=1489758009"></script>
<!--[if lt IE 9]><script type="text/javascript" src="/static/html5shiv.js?_=1484636606"></script><![endif]-->

</head>
	<body class="v8310doc">
<a name="_ref220491674"></a><a name="_ref216159570"></a><a name="_ref449004738"></a><a id="TI000001824" class="bookmark"><h1>Глава 16.  Работа с различными форматами данных</h1></a>

<a name="_ref221519021"></a><a name="_ref448915408"></a><a name="_ref448915407"></a><a name="_ref237783495"></a><a id="TI000000762" class="bookmark" name="issogl1_16.1_механизм_xdto"><h2>16.1. Механизм XDTO</h2></a>

<a id="TI000001474" class="bookmark" name="issogl2_16.1.1_общая_информация"><h3>16.1.1. Общая информация</h3></a>

<p class="MsoNormalCxSpFirst">Механизм
XDTO является универсальным способом представления данных для взаимодействия с
различными внешними источниками данных и программными системами.</p>

<p class="MsoNormalCxSpLast">Аббревиатура XDTO обозначает <span class="Interface">XML Data Transfer Objects</span>.</p>

<p class="Regularbeforepicture">Механизм
XDTO позволяет создать модель представления данных (модель типов и значений),
которая, с одной стороны, обеспечивает возможность просто и естественно манипулировать
данными в среде системы «1С:Предприятие», а с другой стороны, хорошо
приспособлена для прозрачного преобразования данных в другие форматы, главным
образом XML.</p>

<p class="Picture"><IMG src="_img/img00454.gif?_=1496848987" WIDTH="384" ALT HEIGHT="381"></p>

<p class="MsoCaption">Рис.
446.
Общая схема XDTO</p>

<p class="MsoNormal">Можно
выделить несколько задач, для решения которых используется механизм XDTO:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
обмен данными между конфигурациями системы
«1С:Предприятие» с разными схемами данных;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
обмен данными на основе схем XML, не привязанных
к той или иной конфигурации (например, обмен с информационными системами,
построенными не на основе системы «1С:Предприятие»);</p>

<p class="MsoListBulletCxSpLast">&#9679; 
организация работы с Web-сервисами. Механизм XDTO
позволяет описывать типы параметров и возвращаемых значений Web-сервисов, а
также манипулировать передаваемыми и возвращаемыми данными.</p>

<p class="MsoNormal">Механизм
XDTO обладает следующими ключевыми свойствами:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
обеспечивает работу с XML,</p>

<p class="MsoListBulletCxSpLast">&#9679; 
привычная модель работы с данными.</p>

<p class="MsoNormalCxSpFirst">В
настоящее время обмен данными с различными программными платформами и системами
реализуется с использованием XML: XML-документы служат для представления данных,
а схема XML используется для описания форматов и структур данных. Механизм XDTO
позволяет создавать требуемые для обмена схемы XML и формировать XML-документы,
удовлетворяющие этим схемам.</p>

<p class="MsoNormalCxSpMiddle">В
то же время использование механизма XDTO позволяет выполнять эти действия в
привычной, для большинства разработчиков системы «1С:Предприятие», манере.</p>

<p class="MsoNormalCxSpLast">Разработчик
имеет дело с типами и объектами данных, объекты данных содержат свойства,
свойствам присваиваются значения и т. д. При манипулировании данными
с помощью XDTO разработчик максимально изолирован от подробностей, связанных с
тем, как эти данные представлены в XML. Конечно, совсем избавиться от этих
подробностей невозможно, но важно, что они проявляются только там, где это
действительно нужно.</p>

<a id="TI000000763" class="bookmark" name="issogl2_16.1.2_фабрика_xdto"><h3>16.1.2. Фабрика XDTO</h3></a>

<a id="TI000001585" class="bookmark" name="issogl3_16.1.2.1_общая_информация"><h4>16.1.2.1. Общая информация</h4></a>

<p class="MsoNormalCxSpFirst">Ключевым
понятием механизма XDTO является фабрика XDTO. Фабрика XDTO содержит описание
всех типов, с которыми оперирует некоторая система. В частности, для любой
конфигурации системы «1С:Предприятие» существует глобальная фабрика XDTO,
которая описывает все типы, используемые в конфигурации, в терминах XDTO (эта
фабрика XDTO доступна через свойство глобального контекста <span class="Term">ФабрикаXDTO</span>).</p>

<p class="MsoNormalCxSpMiddle">Все
описания типов, которые содержит фабрика XDTO, сгруппированы в один или несколько
пакетов XDTO. Если проводить аналогию между XDTO и XML, то можно сказать, что
пакет XDTO соответствует схеме XML. Таким образом, фабрика XDTO может соответствовать
нескольким схемам XML.</p>

<p class="MsoNormalCxSpMiddle">Фабрика
XDTO является полностью самодостаточной. То есть любой из типов, зарегистрированных
в фабрике XDTO, может ссылаться только на типы из той же самой фабрики XDTO.</p>

<p class="MsoNormalCxSpMiddle">В
общем случае фабрика XDTO создается единовременно на основании описаний всех
типов, которые должны быть зарегистрированы в фабрике. Для создания фабрики XDTO
средствами встроенного языка используется конструктор объекта <span class="Term">ФабрикаXDTO</span>, которому передается набор схем XML,
содержащийся в объекте <span class="Term">НаборСхемXML</span>.
Сценарий, при котором типы XDTO добавляются в фабрику по одному или группами,
не поддерживается.</p>

<p class="MsoNormalCxSpLast">В
отличие от произвольной фабрики XDTO, которую может создать разработчик, глобальная
фабрика XDTO создается системой автоматически, при создании новой информационной
базы, и допускает добавление типов XDTO по одному или группами. Для этого используются
средства визуального конструирования, позволяющие добавлять пакеты XDTO в ветку
дерева метаданных <span class="Interface">Общие – XDTO-пакеты</span>. Все пакеты, содержащиеся в
глобальной фабрике XDTO, можно разделить на три вида:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
Один пакет XDTO, содержащий описание типов платформы.
Этот пакет является одинаковым для всех конфигураций системы «1С:Предприятие».</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
Один пакет XDTO, содержащий описание типов конфигурации,
созданных в результате редактирования метаданных (создания и изменения свойств
справочников, документов и пр.).</p>

<p class="MsoListBulletCxSpLast">&#9679; 
Один или несколько пакетов XDTO, описанных непосредственно
в дереве объектов конфигурации, в ветке <span class="Interface">Общие – XDTO-пакеты</span>.</p>

<p class="MsoNormalCxSpFirst">Пакет
XDTO содержит описание некоторого множества типов, принадлежащих одному
пространству имен – пространству имен пакета. Кроме непосредственно описаний
типов пакет XDTO может содержать ссылки на пакеты, которые используются данным
пакетом, а также список определений глобальных свойств пакета.</p>

<p class="MsoNormalCxSpMiddle">Ссылки
на другие пакеты содержатся в свойстве <span class="Term">Зависимости</span> пакета XDTO и представляют собой
объект <span class="Term">КоллекцияПакетовXDTO</span>.
Пакеты этой коллекции содержат типы из пространства имен, на которые имеются
ссылки в данном пакете.</p>

<p class="MsoNormalCxSpMiddle">В
пакете можно ссылаться на глобальные свойства из других пакетов.</p>

<p class="MsoNormalCxSpLast">Отсутствует
поддержка циклов в директивах импорта и включения XSD-схем.</p>

<a id="TI000001586" class="bookmark" name="issogl3_16.1.2.2_получение_фабрики_xdto_из_файла-схемы_xsd"><h4>16.1.2.2. Получение фабрики XDTO из файла-схемы XSD</h4></a>

<p class="MsoNormal">Ниже
приведен пример создания фабрики XDTO на основе схемы XML, содержащейся в файле
XML. Так как механизм XDTO представляет собой абстракцию, построенную «над» XML,
то для получения схемы XML из файла XML необходимо последовательно «пройти» несколько
уровней работы с данными XML:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
сначала низкоуровневое чтение/запись файлов XML;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
затем объектную модель XML, из которой уже может
быть получен объект встроенного языка <span class="Term">СхемаXML</span>, содержащий данные схемы XML.</p>

<p class="Picture"><IMG src="_img/img00455.gif?_=1496848987" WIDTH="356" ALT HEIGHT="398"></p>

<p class="MsoCaption">Рис.
447.
Создание фабрики XDTO</p>

<p class="Lang-subheader">Пример:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev"><span class="comment">// Создать фабрику XDTO на основе схемы XML,</span>
<span class="comment">// содержащейся в файле XML</span>
<span class="comment">// Создать объект чтения XML по умолчанию</span>
ЧтениеXML <span class="operator">=</span> <span class="keyword">Новый</span> ЧтениеXML<span class="operator">;</span>
<span class="comment">// Открыть файл XML</span>
ЧтениеXML<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;с:\temp\my_sсhema.xsd&quot;</span><span class="operator">)</span><span class="operator">;</span>
<span class="comment">// Создать построитель документа DOM по умолчанию</span>
ПостроительDOM <span class="operator">=</span> <span class="keyword">Новый</span> ПостроительDOM<span class="operator">;</span>
<span class="comment">// Прочитать файл XML в документ DOM</span>
ДокументDOM <span class="operator">=</span> ПостроительDOM<span class="operator">.</span>Прочитать<span class="operator">(</span>ЧтениеXML<span class="operator">)</span><span class="operator">;</span>
<span class="comment">// Создать построитель схемы XML по умолчанию</span>
ПостроительСхемыXML <span class="operator">=</span> <span class="keyword">Новый</span> ПостроительСхемXML<span class="operator">;</span>
<span class="comment">// Получить схему XML из документа DOM</span>
СхемаXML <span class="operator">=</span> ПостроительСхемыXML<span class="operator">.</span>СоздатьСхемуXML<span class="operator">(</span>ДокументDOM<span class="operator">)</span><span class="operator">;</span>
<span class="comment">// Создать набор схем XML по умолчанию</span>
НаборСхемXML <span class="operator">=</span> <span class="keyword">Новый</span> НаборСхемXML<span class="operator">;</span>
<span class="comment">// Добавить схему XML в набор схем XML</span>
НаборСхемXML<span class="operator">.</span>Добавить<span class="operator">(</span>СхемаXML<span class="operator">)</span><span class="operator">;</span>
<span class="comment">// Создать фабрику XDTO на основе набора схем XML</span>
НоваяФабрикаXDTO <span class="operator">=</span> <span class="keyword">Новый</span> ФабрикаXDTO<span class="operator">(</span>НаборСхемXML<span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">В
приведенном примере сначала создается объект <span class="Term">ЧтениеXML</span> и открывается файл XML,
расположенный на диске. После этого с помощью построителя документа DOM
создается объект <span class="Term">ДокументDOM</span>,
содержащий данные файла XML. Затем с помощью построителя схемы XML на основе
документа DOM создается новый объект <span class="Term">СхемаXML</span>, содержащий данные схемы XML. В заключение
создается пустой набор схем XML, в который добавляется имеющаяся схема XML, и
на основании этого набора создается фабрика XDTO.</p>

<a id="TI000000764" class="bookmark" name="issogl3_16.1.2.3_получение_фабрики_xdto_из_нескольких_источников"><h4>16.1.2.3. Получение фабрики XDTO из нескольких источников</h4></a>

<p class="MsoNormal">В
некоторых случаях может потребоваться создать фабрику на основании нескольких
схем, некоторые из которых могут поставляться в виде файлов, а некоторые
необходимо «унаследовать» от других фабрик XDTO (включая глобальную фабрику).</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">Схемы <span class="operator">=</span> <span class="keyword">Новый</span> Массив<span class="operator">;</span>
Схемы<span class="operator">.</span>Добавить<span class="operator">(</span><span class="string">&quot;с:\temp\sсhema 1.xsd&quot;</span><span class="operator">)</span><span class="operator">;</span>
Схемы<span class="operator">.</span>Добавить<span class="operator">(</span><span class="string">&quot;с:\temp\sсhema 2.xsd&quot;</span><span class="operator">)</span><span class="operator">;</span>
Пакеты <span class="operator">=</span> <span class="keyword">Новый</span> Массив<span class="operator">;</span>
Пакеты<span class="operator">.</span>Добавить<span class="operator">(</span>ФабрикаXDTO<span class="operator">.</span>Пакеты<span class="operator">.</span>Получить<span class="operator">(</span><span class="string">&quot;URI пакета 1&quot;</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
Пакеты<span class="operator">.</span>Добавить<span class="operator">(</span>ФабрикаXDTO<span class="operator">.</span>Пакеты<span class="operator">.</span>Получить<span class="operator">(</span><span class="string">&quot;URI пакета 2&quot;</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
МояФабрика <span class="operator">=</span> СоздатьФабрикуXDTO<span class="operator">(</span>Схемы<span class="operator">,</span> Пакеты<span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">В
данном примере выполняется формирование фабрики XDTO на основании 4 источников:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
Схемы XML, которая расположена в файле <span class="Interface">с:\temp\sсhema 1.xsd</span>.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
Схемы XML, которая расположена в файле <span class="Interface">с:\temp\sсhema 2.xsd</span>.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
Схемы <span class="Interface">пакета 1</span>
текущей конфигурации.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
Схемы <span class="Interface">пакета 2</span>
текущей конфигурации.</p>

<p class="MsoNormal">В
общем случае, необязательно, чтобы пакеты получались из глобальной фабрики
XDTO. Это может быть произвольная фабрика.</p>

<a id="TI000000765" class="bookmark" name="issogl2_16.1.3_типы_данных_xdto"><h3>16.1.3. Типы данных XDTO</h3></a>

<a id="TI000001710" class="bookmark" name="issogl3_16.1.3.1_общая_информация"><h4>16.1.3.1. Общая информация</h4></a>

<p class="MsoNormalCxSpFirst">Каждый
из типов данных XDTO является либо типом значения XDTO, либо типом объекта XDTO.
Соответственно, для описания типа значения используется объект <span class="Term">ТипЗначенияXDTO</span>, а для описания типа
объекта – <span class="Term">ТипОбъектаXDTO</span>.</p>

<p class="MsoNormalCxSpMiddle">Объект
<span class="Term">ТипЗначенияXDTO</span>
используется для описания типов простых неделимых значений, в которых не могут
быть выделены отдельные составляющие. Примерами простых значений являются
разнообразные строки, числа, даты и т. п.</p>

<p class="MsoNormalCxSpMiddle">Объект
<span class="Term">ТипОбъектаXDTO</span>
используется для описания типов экземпляров данных, имеющих некоторое состояние,
представляемое как совокупность значений свойств этого экземпляра данных. При
этом типы свойств этого экземпляра данных могут являться как типами значений XDTO,
так и типами объектов XDTO.</p>

<p class="MsoNormalCxSpLast">И <span class="Term">ТипЗначенияXDTO</span>, и <span class="Term">ТипОбъектаXDTO</span> имеют два одинаковых свойства:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
<span class="Term">Имя</span> – имя типа;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
<span class="Term">URIПространстваИмен</span> – URI пространства
имен, в котором определен данный тип.</p>

<p class="MsoNormal">Значения
этих свойств совпадают с аналогичными параметрами, с которыми тип определяется
в схеме XML. Имя типа и URI пространства имен образуют уникальный идентификатор
типа. Имя типа должно быть обязательно определено. При этом свойство <span class="Term">URIПространстваИмен</span> может содержать пустую
строку, хотя это и нежелательно.</p>

<a id="TI000000766" class="bookmark" name="issogl3_16.1.3.2_тип_значения_xdto"><h4>16.1.3.2. Тип значения XDTO</h4></a>

<p class="MsoNormal">Тип
значения XDTO в соответствии с правилами для <span class="Interface">simple type</span> из
схемы XML может определяться тремя способами:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
ограничением, когда задается базовый тип
(свойство <span class="Term">БазовыйТип</span>)
и набор ограничений на множество возможных значений (свойство <span class="Term">Фасеты</span>);</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
объединением, когда тип получается в результате
объединения нескольких типов значений (объединяемые типы перечисляются в
свойстве <span class="Term">ТипыЧленовОбъединения</span>);</p>

<p class="MsoListBulletCxSpLast">&#9679; 
списком, когда значение представляет собой
список значений (тип значения элементов, составляющих список значений, задается
в свойстве <span class="Term">ТипЭлементаСписка</span>).</p>

<p class="MsoNormal">Помимо
свойств <span class="Term">Имя</span>
и <span class="Term">URIПространстваИмен</span>
тип значения XDTO содержит следующие свойства:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
<span class="Term">БазовыйТип</span> – базовый тип для данного типа
значения XDTO. Базовые типы могут наследоваться, но только от других типов
значений XDTO. Допустимое множество значений унаследованного типа представляет
собой подмножество возможных значений базового типа. Верхним уровнем в иерархии
простых типов является предопределенный тип <span class="Term">anySimpleType</span> из пространства имен <span class="Interface">http://www.w3.org/2001/XMLSchema</span>.
Все типы значений прямо или опосредованно унаследованы от этого типа. Типы,
образованные объединением или списком, всегда непосредственно унаследованы от <span class="Term">anySimpleType</span>.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Фасеты</span> – список фасетов, ограничивающих
множество допустимых значений по отношению к базовому типу. Список фасетов
задается только для типов значений XDTO, определенных ограничением базового
типа. Каждый отдельный фасет представляет собой пару: имя фасета и значение.
Определен список имен допустимых фасетов. Причем не любой из допустимых фасетов
может быть применен к любому типу. Список фасетов и применимость их к тому или
иному типу определяются по правилам XML Schema (<span class="Interface">http://www.w3.org/TR/xmlschema-2/</span>).</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">ТипыЧленовОбъединения</span> – список типов,
образующих объединение. Объединяться могут только типы значений XDTO. Если тип
образован объединением, то список <span class="Term">ТипыЧленовОбъединения</span>
содержит по крайней мере один тип. При этом список <span class="Term">Фасеты</span> должен быть пустым, а свойство <span class="Term">ТипЭлементаСписка</span> должно возвращать неопределенное
значение.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">ТипЭлементаСписка</span> – в случае, когда тип
значения XDTO определяется списком, данное свойство показывает тип элемента
списка. При этом списки <span class="Term">Фасеты</span>
и <span class="Term">ТипыЧленовОбъединения</span>
должны быть пустыми.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
Список имен допустимых фасетов (определяется
системным перечислением <span class="Term">ВидФасетаXDTO</span>):</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
<span class="Term">Длина</span> – фасет длины. Содержит количество
единиц длины, причем единица длины имеет различный смысл для различных типов.
Для типов <span class="Term">string</span>
и <span class="Term">anyURI</span>
длина содержит количество символов. Для типов <span class="Term">hexBinary</span> и <span class="Term">base64Binary</span> длина содержит количество байт
двоичных данных. Для типов, определяемых списком, длина содержит количество элементов
списка.</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
<span class="Term">МаксВключающее</span> – фасет максимума,
включающего границу. Ограничивает пространство значений данного типа максимальным
значением. Любое значение данного типа меньше либо равно указанному значению.</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
<span class="Term">МаксДлина</span> – фасет максимальной длины.
Содержит максимальное количество единиц длины, причем единица длины имеет
различный смысл для различных типов. Для типа <span class="Term">string</span> максимальная длина содержит максимальное
количество символов. Для типов <span class="Term">hexBinary</span>
и <span class="Term">base64Binary</span>
максимальная длина содержит максимальное количество байт двоичных данных. Для
типов, определяемых списком, максимальная длина содержит максимальное
количество элементов списка.</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
<span class="Term">МаксИсключающее</span> – фасет максимума, не включающего
границу. Ограничивает пространство значений данного типа максимальным значением.
Любое значение данного типа меньше указанного значения.</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
<span class="Term">МинВключающее</span> – фасет минимума,
включающего границу. Ограничивает пространство значений данного типа минимальным
значением. Любое значение данного типа больше либо равно указанному значению.</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
<span class="Term">МинДлина</span> – фасет минимальной длины.
Содержит минимальное количество единиц длины, причем единица длины имеет
различный смысл для различных типов. Для типа <span class="Term">string</span> минимальная длина содержит минимальное
количество символов. Для типов <span class="Term">hexBinary</span>
и <span class="Term">base64Binary</span>
минимальная длина содержит минимальное количество байт двоичных данных. Для
типов, определяемых списком, минимальная длина содержит минимальное количество
элементов списка.</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
<span class="Term">МинИсключающее</span> – фасет минимума, не
включающего границу. Ограничивает пространство значений данного типа
минимальным значением. Любое значение данного типа больше указанного значения.</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
<span class="Term">Образец</span> – фасет образца. Содержит
регулярное выражение, определяющее пространство значений данного типа.</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
<span class="Term">Перечисление</span> – фасет перечисления.
Определяет набор допустимых значений данного типа.</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
<span class="Term">ПробельныеСимволы</span> – фасет пробельных
символов. Может принимать одно из трех значений:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
<span class="Term">Сохранять</span> – строка может содержать любые
пробельные символы.</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
<span class="Term">Заменять</span> – строка не должна содержать #x9
(табуляция), #xA (перевод строки) и #xD (возврат каретки). Если они существуют,
то должны быть заменены символом #x20 (пробел).</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
<span class="Term">Сворачивать</span> – дополнительно к
требованиям, указанным для значения <span class="Term">replace</span>, строка не должна содержать парных
символов #x20 (пробел), а также лидирующих и завершающих символов #x20 (пробел).</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
<span class="Term">РазрядовВсего</span> – фасет общего количества
цифр. Содержит общее количество разрядов числа (целая часть плюс дробная
часть).</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
<span class="Term">РазрядовДробнойЧасти</span> – фасет количества
цифр дробной части. Содержит количество разрядов дробной части числа.</p>

<p class="MsoNormal">Инфраструктура
XDTO определяет набор предопределенных типов значений XDTO. Этот набор
совпадает с набором примитивных типов, определенных в XML Schema Part 2:
Datatypes. Предопределенные типы образуют иерархию в соответствии с XML Schema
Part 2: Datatypes. Имена типов совпадают с именами типов XML Schema и
принадлежат URI пространства имен – <span class="Interface">http://www.w3.org/2001/XMLSchema</span>.
Предопределенные типы являются автоматически зарегистрированными в любой
фабрике XDTO.</p>

<a id="TI000000767" class="bookmark" name="issogl3_16.1.3.3_тип_объекта_xdto"><h4>16.1.3.3. Тип объекта XDTO</h4></a>

<p class="MsoNormal">Помимо
свойств <span class="Term">Имя</span>
и <span class="Term">URIПространстваИмен</span>
тип объекта XDTO содержит следующие свойства:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
<span class="Term">БазовыйТип</span> – базовый тип для данного
типа. Это может быть только тип объекта XDTO. Базовым в иерархии типов объектов
XDTO является предопределенный тип <span class="Term">anyType</span>
из пространства имен <span class="Interface">http://www.w3.org/2001/XMLSchema</span>. Все типы объектов XDTO
прямо или опосредованно унаследованы от этого типа.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Открытый</span> – признак того, является ли тип
объекта XDTO открытым. Данное свойство показывает, может ли экземпляр объекта XDTO
содержать дополнительные свойства, не определенные в его типе, то есть
реализует модель <span class="Interface">open </span><span class="Interface">content</span>.
Соответствует появлению в XML-схеме для данного типа описаний: <span class="Interface">&lt;anyAttribute&gt;</span>,
<span class="Interface">&lt;any&gt;</span>.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Абстрактный</span> – признак того, является ли
тип объекта XDTO абстрактным. Соответствует появлению в схеме для данного
элемента атрибута <span class="Interface">abstract=&quot;true&quot;</span>.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Упорядоченный</span> – признак того, является ли
порядок следования элементов, представляющих значения свойств, строго соответствующим
порядку следования свойств в типе объекта XDTO. Если задана модель контента <span class="Interface">xsd:all</span>, то
порядок следования элементов XML может быть произвольным. При этом допустимым
является порядок, соответствующий порядку следования свойств в типе. То есть
если свойство <span class="Term">Упорядоченный</span>
имеет значение <span class="Term">Ложь</span>,
то на входе порядок следования элементов XML не контролируется, а на выходе
определяется порядком следования свойств, если только признак <span class="Term">Последовательный</span> не имеет значение <span class="Term">Истина</span>.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Последовательный</span> – это свойство
показывает, содержит ли экземпляр соответствующего объекта XDTO последовательность
XDTO. Данный признак равен значению <span class="Term">Истина</span> в тех случаях, когда порядок следования
вложенных элементов XML не может однозначно определяться порядком следования
свойств в типе (например, в схеме XML контент задан как <span class="Interface">&lt;sequence … maxOccurs=10 … &gt;</span>) или для
соответствующего типа XML в схеме определен атрибут <span class="Interface">mixed=&quot;true&quot;</span>.
Последовательность XDTO позволяет задать в явном виде порядок следования
элементов, как они будут представлены в документе XML. Для объектов типов, у
которых свойство <span class="Term">Последовательный</span>
установлено в значение <span class="Term">Ложь</span>,
порядок следования вложенных элементов соответствует порядку следования
свойств.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Смешанный</span> – свойство показывает,
определен ли в схеме XML для данного типа <span class="Interface">mixed </span><span class="Interface">content</span>. Если значение свойства <span class="Term">Смешанный</span> равно <span class="Term">Истина</span>, то значение <span class="Term">Последовательный</span> обязательно равно <span class="Term">Истина</span>, так как <span class="Interface">mixed </span><span class="Interface">content</span> невозможно смоделировать
без применения последовательности XDTO.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
<span class="Term">Свойства</span> – список свойств, определенных
для данного типа объекта XDTO. Каждое из свойств представляется в виде экземпляра
объекта <span class="Term">СвойствоXDTO</span>.
Список содержит полный список свойств, в том числе свойства, определенные в базовом
типе.</p>

<p class="MsoNormalCxSpFirst">Существует
предопределенный тип объекта XDTO с именем <span class="Term">anyType</span> и URI пространства имен <span class="Interface">http://www.w3.org/2001/XMLSchema</span>.
Данный тип является базовым для любого типа объекта XDTO, но у него нет
базового типа. Он является открытым, не абстрактным, подразумевает наличие
последовательности и имеет пустой список свойств.</p>

<p class="MsoNormalCxSpLast">Данный
тип объекта XDTO соответствует типу <span class="Term">anyType</span>, определенному в XML Schema Part 2:
Datatypes.</p>

<a name="_ref342389685"></a><a id="TI000000768" class="bookmark" name="issogl3_16.1.3.4_свойство_xdto"><h4>16.1.3.4. Свойство XDTO</h4></a>

<p class="MsoNormalCxSpFirst">Отдельно
взятое свойство отдельного типа объекта XDTO описывается с помощью экземпляра
объекта <span class="Term">СвойствоXDTO</span>.
Это означает, что один и тот же экземпляр объекта <span class="Term">СвойствоXDTO</span> не может быть использован для
описания свойств в различных типах объектов XDTO и двух различных свойств
одного типа объекта XDTO.</p>

<p class="MsoNormalCxSpLast">Объект
<span class="Term">СвойствоXDTO</span>
содержит следующие свойства:</p>

<p class="MsoListBullet">&#9679; 
<span class="Term">Имя</span> – имя свойства. В пределах одного
типа объекта XDTO имена свойств должны быть уникальными.</p>

<p class="IndentlistCxSpFirst">При
формировании модели данных XDTO на основе схемы XSD, имена свойств XDTO
образуются на основании имен атрибутов и элементов, описанных в схеме.
Построение модели типа выполняется последовательно: сначала формируется список
свойств на основе атрибутов, затем – на основе элементов, в порядке
объявления в схеме.</p>

<p class="IndentlistCxSpLast">При
этом имя приводится в соответствие с правилами именования, принятыми во
встроенном языке. Символы, допустимые в имени XML (например: &quot;<span class="Interface">.</span>&quot;, &quot;<span class="Interface">-</span>«'), но
недопустимые с точки зрения имени для встроенного языка – заменяются на
символ &quot;<span class="Interface">_</span>&quot;. В случае дублирования имени атрибута и
элемента, дубликату назначается имя, расширенное числовым суффиксом (начиная от
1).</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
<span class="Term">Тип</span> – тип свойства. Может быть как
экземпляром объекта <span class="Term">ТипЗначенияXDTO</span>,
так и экземпляром объекта <span class="Term">ТипОбъектаXDTO</span>.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">ВерхняяГраница</span> – свойство типа объекта XDTO
может быть определено как содержащее одно или множество значений. Свойство
считается содержащим одно значение, если равно 1. Если же свойство <span class="Term">ВерхняяГраница</span> больше 1, то считается, что оно
может содержать множество значений. Такое свойство в структуре объекта моделируется
как список (не путать со списком в описании типа значения XDTO). Свойство <span class="Term">ВерхняяГраница</span> показывает максимальное
количество значений свойства. Значение больше 1 может быть задано только для
свойств, представляемых в виде элемента XML. Свойство <span class="Term">ВерхняяГраница</span> соответствует атрибуту <span class="Interface">xsd:maxOccurs</span> в
XML Schema. Значение -1 соответствует <span class="Term">unbounded</span>.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">НижняяГраница</span> – минимальное количество
значений свойства. Минимальное количество значений свойства может принимать
значения меньше или равно 0. Естественно, значение <span class="Term">НижняяГраница</span> должно быть меньше или равно
значению <span class="Term">ВерхняяГраница</span>
(если, конечно, <span class="Term">ВерхняяГраница</span>
не равно -1);</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">ВозможноПустое</span> – показывает, может ли
свойство принимать неопределенное значение. Неопределенное значение свойства
представляется в XML в виде элемента следующего вида: <span class="Interface">&lt;elem xsi:nil=&quot;true&quot;
/&gt;</span>. Таким образом, свойство <span class="Term">ВозможноПустое</span>, равное <span class="Term">Истина</span>, может быть определено только для
свойств с формой представления <span class="Term">Элемент</span>.
Свойство <span class="Term">ВозможноПустое</span>
соответствует атрибуту <span class="Term">xsd:nillable</span>
в XML Schema. Если значение свойства <span class="Term">ВерхняяГраница</span> больше 1, неопределенное
значение является допустимым для элемента списка значений свойства.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">ЗначениеПоУмолчанию</span> – значение свойства
по умолчанию. Значением свойства по умолчанию может быть только <span class="Term">ЗначениеXDTO</span>. При этом данное значение должно
быть того же типа, что и тип свойства или же унаследованного типа. При создании
объекта XDTO свойство, если оно допускает единственное значение, принимает
значение по умолчанию (метод <span class="Term">Установлено()</span>
объекта XDTO возвращает значение <span class="Term">Ложь</span>
для этого свойства). Для свойств с множеством значений список значений
изначально пуст, независимо от того, определено или нет значение по умолчанию.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Фиксированное</span> – указывает, является ли
значение свойства фиксированным. Если установлено в значение <span class="Term">Истина</span>, то само фиксированное значение можно
получить через свойство <span class="Term">ЗначениеПоУмолчанию</span>.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Форма</span> – форма представления свойства в
XML. Это может быть <span class="Term">Текст</span>,
<span class="Term">Элемент</span>
или <span class="Term">Атрибут</span>.
Если формой представления является <span class="Term">Атрибут</span>
или <span class="Term">Текст</span>,
то значение свойства <span class="Term">ВерхняяГраница</span>
не может быть больше 1. Если свойство принимает значение <span class="Term">Текст</span>, то значение свойства <span class="Term">НижняяГраница</span> также должно быть равным 1. У одного
типа только одно свойство может иметь форму представления <span class="Term">Текст</span>, при этом остальные свойства должны
иметь форму представления <span class="Term">Атрибут</span>.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">ЛокальноеИмя</span> – локальное имя атрибута или
элемента, используемого для представления свойства. Для свойств с формой
представления <span class="Term">Текст</span> –
пустая строка.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
<span class="Term">URIПространстваИмен</span> – URI пространства
имен для атрибута или элемента, используемого для представления свойства.
Пустая строка, если пространство имен отсутствует.</p>

<a id="TI000000769" class="bookmark" name="issogl2_16.1.4_экземпляры_данных_xdto"><h3>16.1.4. Экземпляры данных XDTO</h3></a>

<p class="MsoNormal">Экземпляры
данных XDTO могут являться значениями XDTO (<span class="Term">ЗначениеXDTO</span>) или объектами XDTO (<span class="Term">ОбъектXDTO</span>).</p>

<a id="TI000000770" class="bookmark" name="issogl3_16.1.4.1_значение_xdto"><h4>16.1.4.1. Значение XDTO</h4></a>

<p class="MsoNormalCxSpFirst">Значение
XDTO представляет собой простое неделимое значение, в котором не могут быть
выделены отдельные составляющие. Примерами простых значений являются разнообразные
строки, числа, даты и т. п. Экземпляры простых значений являются немутабельными.</p>

<p class="MsoNormalCxSpLast">Новое
значение XDTO может быть создано с помощью метода <span class="Term">Создать()</span> фабрики XDTO:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
на основе типа значения XDTO и значения;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
на основе типа значения XDTO и лексического представления
значения.</p>

<p class="MsoNormal">Ниже
приведены примеры создания значения XDTO.</p>

<p class="Lang-subheader">Пример:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">ГлобальнаяФабрикаXDTO <span class="operator">=</span> ФабрикаXDTO<span class="operator">;</span>
<span class="comment">// Создать значение XDTO из ссылки</span>
СсылкаНаЭлементСправочника <span class="operator">=</span> Справочники<span class="operator">.</span>Номенклатура<span class="operator">.</span> НайтиПоКоду<span class="operator">(</span><span class="string">&quot;0000001&quot;</span><span class="operator">)</span><span class="operator">;</span>
ТипЗначенияXDTOСоздаваемогоЗначения <span class="operator">=</span> ГлобальнаяФабрикаXDTO<span class="operator">.</span>Тип<span class="operator">(</span><span class="string">&quot;urn:schemas-v8-1c-ru:config-data&quot;</span><span class="operator">,</span> <span class="string">&quot;CatalogRef.Номенклатура&quot;</span><span class="operator">)</span><span class="operator">;</span>
НовоеЗначениеXDTO <span class="operator">=</span> ГлобальнаяФабрикаXDTO<span class="operator">.</span>Создать<span class="operator">(</span>ТипЗначенияXDTOСоздаваемогоЗначения<span class="operator">,</span> СсылкаНаЭлементСправочника<span class="operator">)</span><span class="operator">;</span>
<span class="comment">// Создать значение XDTO из лексического представления значения</span>
ТипЗначенияXDTOСоздаваемогоЗначения <span class="operator">=</span> ГлобальнаяФабрикаXDTO<span class="operator">.</span>Тип<span class="operator">(</span><span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span><span class="operator">,</span> <span class="string">&quot;dateTime&quot;</span><span class="operator">)</span><span class="operator">;</span>
НовоеЗначениеXDTO <span class="operator">=</span> ГлобальнаяФабрикаXDTO<span class="operator">.</span>Создать<span class="operator">(</span>ТипЗначенияXDTOСоздаваемогоЗначения<span class="operator">,</span> <span class="string">&quot;2006-04-20T12:00:30&quot;</span><span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">Новое
значение XDTO может быть получено также путем чтения файла XML.</p>

<p class="Lang-subheader">Пример:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">ГлобальнаяФабрикаXDTO <span class="operator">=</span> ФабрикаXDTO<span class="operator">;</span><span class="operator">,</span>
<span class="comment">// Прочитать данные значения XDTO из файла XML</span>
НовоеЧтениеXML <span class="operator">=</span> <span class="keyword">Новый</span> ЧтениеXML<span class="operator">;</span>
НовоеЧтениеXML<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;D:/Exchange.xml&quot;</span><span class="operator">)</span><span class="operator">;</span>
…
НовоеЗначениеXDTO <span class="operator">=</span> ГлобальнаяФабрикаXDTO<span class="operator">.</span> ПрочитатьXML<span class="operator">(</span>НовоеЧтениеXML<span class="operator">)</span><span class="operator">;</span>
Значение XDTO может быть записано в файл XML<span class="operator">.</span>
ГлобальнаяФабрикаXDTO <span class="operator">=</span> ФабрикаXDTO<span class="operator">;</span>
<span class="comment">// Записать данные значения XDTO в файл XML</span>
НоваяЗаписьXML <span class="operator">=</span> <span class="keyword">Новый</span> ЗаписьXML<span class="operator">;</span>
НоваяЗаписьXML<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;D:/Exchange.xml&quot;</span><span class="operator">)</span><span class="operator">;</span>
…
ГлобальнаяФабрикаXDTO<span class="operator">.</span>ЗаписатьXML<span class="operator">(</span>НоваяЗаписьXML<span class="operator">,</span> НовоеЗначениеXDTO<span class="operator">)</span><span class="operator">;</span></pre>

<a id="TI000000771" class="bookmark" name="issogl3_16.1.4.2_объект_xdto"><h4>16.1.4.2. Объект XDTO</h4></a>

<p class="MsoNormalCxSpFirst">В
противовес простому значению состояние объекта XDTO представляется как
совокупность значений его свойств. Экземпляры объекта XDTO являются мутабельными,
то есть во время жизни объекта XDTO его состояние может быть изменено путем
изменения значений отдельных его свойств. В качестве значений свойств могут
фигурировать любые экземпляры данных XDTO, как значение XDTO, так и объект
XDTO. Когда значением свойства является объект XDTO, говорят, что значением
свойства является ссылка на объект.</p>

<p class="MsoNormalCxSpLast">Новый
объект XDTO может быть создан с помощью метода <span class="Term">Создать()</span> фабрики XDTO, на основе типа объекта
XDTO. После этого следует присвоить соответствующие значения свойствам объекта XDTO.
Ниже приведен пример создания объекта XDTO и заполнения его свойств.</p>

<p class="Lang-subheader">Пример:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">ГлобальнаяФабрикаXDTO <span class="operator">=</span> ФабрикаXDTO<span class="operator">;</span>
<span class="comment">// Создать &quot;пустой&quot; объект XDTO</span>
ТипОбъектаXDTOСоздаваемогоОбъекта <span class="operator">=</span> ГлобальнаяФабрикаXDTO<span class="operator">.</span>Тип<span class="operator">(</span><span class="string">&quot;http://www.1c.ru/demos/products&quot;</span><span class="operator">,</span> <span class="string">&quot;Номенклатура&quot;</span><span class="operator">)</span><span class="operator">;</span>
НовыйОбъектХDTO <span class="operator">=</span> ГлобальнаяФабрикаXDTO<span class="operator">.</span>Создать<span class="operator">(</span>ТипОбъектаXDTOСоздаваемогоОбъекта<span class="operator">)</span><span class="operator">;</span>
<span class="comment">// Заполнить значения свойств объекта XDTO</span>
ОбъектСправочника <span class="operator">=</span> СсылкаНаЭлементСправочника<span class="operator">.</span>ПолучитьОбъект<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
НовыйОбъектХDTO<span class="operator">.</span>Наименование <span class="operator">=</span> ОбъектСправочника<span class="operator">.</span>Наименование<span class="operator">;</span>
НовыйОбъектХDTO<span class="operator">.</span>ПолноеНаименование <span class="operator">=</span> ОбъектСправочника<span class="operator">.</span>ПолноеНаименование<span class="operator">;</span>
НовыйОбъектХDTO<span class="operator">.</span>ЗакупочнаяЦена <span class="operator">=</span> ОбъектСправочника<span class="operator">.</span>ЗакупочнаяЦена<span class="operator">;</span>
НовыйОбъектХDTO<span class="operator">.</span>ШтрихКод <span class="operator">=</span> ОбъектСправочника<span class="operator">.</span>ШтрихКод<span class="operator">;</span></pre>

<p class="MsoNormal">Так
же как и значение XDTO, данные объекта XDTO могут быть прочитаны из файла XML
или записаны в файл XML.</p>

<p class="Lang-subheader">Пример:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">ГлобальнаяФабрикаXDTO <span class="operator">=</span> ФабрикаXDTO<span class="operator">;</span><span class="operator">,</span>
<span class="comment">// Прочитать данные объекта XDTO из файла XML</span>
НовоеЧтениеXML <span class="operator">=</span> <span class="keyword">Новый</span> ЧтениеXML<span class="operator">;</span>
НовоеЧтениеXML<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;D:/Exchange.xml&quot;</span><span class="operator">)</span><span class="operator">;</span>
…
НовыйОбъектXDTO <span class="operator">=</span> ГлобальнаяФабрикаXDTO<span class="operator">.</span>ПрочитатьXML<span class="operator">(</span>НовоеЧтениеXML<span class="operator">)</span><span class="operator">;</span>
…
<span class="comment">// Записать данные объекта XDTO в файл XML</span>
НоваяЗаписьXML <span class="operator">=</span> <span class="keyword">Новый</span> ЗаписьXML<span class="operator">;</span>
НоваяЗаписьXML<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;D:/Exchange.xml&quot;</span><span class="operator">)</span><span class="operator">;</span>
…
ГлобальнаяФабрикаXDTO<span class="operator">.</span>ЗаписатьXML<span class="operator">(</span>НоваяЗаписьXML<span class="operator">,</span>НовыйОбъектХDTO<span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormalCxSpFirst">При чтении нетипизированных данных, считываемый элемент, в
случае наличия атрибутов или дочерних элементов, считывается в <span class="Term">ОбъектXDTO</span>
типа <span class="Term">xsd:anyType</span>. Данный тип является открытым
типом со смешанным содержимым, поэтому текст в элементе интерпретируется не как
значение свойства <span class="Term">__content</span>, а как текст и помещается в последовательность
объекта.</p>

<p class="MsoNormalCxSpMiddle">Например, если выполняет чтение элемента
вида <span class="Interface">&lt;element attr=&quot;attr_value&quot;&gt;element
value&lt;/element&gt;</span>, то текст <span class="Interface">element value</span> можно получить следующим образом <span class="Term">ОбъектXDTO.Последовательность().ПолучитьТекст(0)</span>.</p>

<p class="MsoNormalCxSpLast">Объект
<span class="Term">ОбъектXDTO</span>
содержит следующие методы:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
<span class="Term">Тип()</span> – возвращает тип данного объекта XDTO
(<span class="Term">ТипОбъектаXDTO</span>);</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Установить(&lt;Выражение&gt;), Установить(&lt;Свойство&gt;,
&lt;Значение&gt;)</span> – позволяет установить значение свойства;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Выражение</span> – выражение на XPath,
указывающее свойство;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Свойство</span> – имя свойства;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
<span class="Term">Значение</span> – устанавливаемое значение
свойства.</p>

<p class="MsoNormalCxSpFirst">Если
<span class="Term">Выражение</span>
задано неправильно или <span class="Term">Значение</span>
не может быть присвоено свойству (например, тип несовместим с типом свойства),
то вызывается исключение. Если свойству присваивается неопределенное значение,
а свойство <span class="Term">ВозможноПустое</span>
равно <span class="Term">Ложь</span>,
то выдается исключение. Если свойству присваивается ссылка на объект XDTO и
ссылка на этот объект XDTO уже является значением какого-либо другого свойства,
то данная ссылка перестает быть значением этого другого свойства.</p>

<p class="MsoNormalCxSpLast">Цепочки
ссылок на объекты XDTO, содержащиеся в свойствах объектов, не могут
образовывать циклов. Поэтому при присваивании ссылки на объект XDTO, вызывающий
образование цикла, вызывается исключение. Если свойство допускает множество значений,
то для него применение метода <span class="Term">Установить()</span>
недопустимо и приводит к вызову исключения. При присваивании значения свойству
производится проверка на допустимость присваивания данного типа значения свойству.
Значение может быть присвоено в том случае, если его тип совпадает с типом
свойства, является унаследованным от типа свойства или является одним из типов,
входящих в объединение. При присваивании, если формой представления значения
свойства в XML является <span class="Term">Текст</span>
или <span class="Term">Атрибут</span>,
производится приведение значения к типу свойства. Если формой представления
является <span class="Term">Элемент</span>,
значение присваивается как есть.</p>

<p class="MsoListBullet">&#9679; 
<span class="Term">Получить(&lt;Свойство&gt;), Получить(&lt;Выражение&gt;)</span> –
получение значения свойства:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
<span class="Term">Свойство</span> – имя свойства.</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
<span class="Term">Выражение</span> – выражение на XPath,
указывающее свойство. Для свойств с множеством значений данный метод возвращает
список значений свойства – <span class="Term">СписокXDTO</span>.
Все операции модификации значений свойства должны выполняться через этот список.</p>

<p class="MsoListBullet">&#9679; 
<span class="Term">Сбросить(&lt;Свойство&gt;), Сбросить (&lt;Выражение&gt;)</span> –
сброс значения свойства:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
<span class="Term">Свойство</span> – имя свойства.</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
<span class="Term">Выражение</span> – выражение на XPath,
указывающее свойство. Действие метода <span class="Term">Сбросить()</span> для различных свойств различно. Для
свойств, допускающих множество значений (<span class="Term">ВерхняяГраница &gt; 1</span>), выполнение метода <span class="Term">Сбросить()</span> приводит к очистке списка значений.</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
<span class="Term">Установлено()</span> – проверяет, установлено ли
значение свойства. Непосредственно после создания объекта у всех свойств
результатом выполнения метода <span class="Term">Установлено()</span>
будет значение <span class="Term">Ложь</span>.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Последовательность()</span> – возвращает
объект-последовательность (<span class="Term">ПоследовательностьXDTO</span>),
принадлежащий данному объекту XDTO. С помощью последовательности XDTO также
можно модифицировать состояние объекта. Данный метод возвращает последовательность
XDTO только в том случае, если у типа объекта установлено свойство <span class="Term">Последовательный</span>.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
<span class="Term">Проверить()</span> – данный метод позволяет
проверить правильность заполнения значений свойств объекта XDTO. При проверке
проверяются также объекты, ссылки на которые являются значениями свойств.
Предметом проверки является соответствие количества значений свойств свойствам <span class="Term">НижняяГраница</span> и <span class="Term">ВерхняяГраница</span>, правильность следования
значений свойств в последовательности XDTO, если свойство <span class="Term">Упорядоченный</span> имеет значение <span class="Term">Истина</span>. Проверка прекращается при нахождении
первой же ошибки. При этом выдается исключение.</p>

<a id="TI000000772" class="bookmark" name="issogl3_16.1.4.3_последовательность_xdto"><h4>16.1.4.3. Последовательность XDTO</h4></a>

<p class="MsoNormalCxSpFirst">С
помощью объекта <span class="Term">ПоследовательностьXDTO</span>
моделируется порядок следования элементов и фрагментов текста, как они выглядят
в XML-представлении объекта. Последовательность состоит из пар «свойство –
значение». В качестве свойств могут выступать только свойства с формой представления
<span class="Term">Элемент</span>,
так как порядок следования атрибутов не важен. Свойство в паре «свойство –
значение» может также иметь неопределенное значение. В этом случае считается,
что данный элемент последовательности представляет фрагмент текста. Появление
элементов последовательности, представляющих фрагменты текста, допустимо только
для объектов типов, у которых значение свойства <span class="Term">Смешанный</span> равно <span class="Term">Истина</span>.</p>

<p class="MsoNormalCxSpMiddle">При
формировании содержимого объекта XDTO с помощью присваивания значений свойствам
порядок присваивания отражается в последовательности XDTO.</p>

<p class="MsoNormalCxSpLast">Последовательность
XDTO содержит следующие методы:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
<span class="Term">Количество()</span> – возвращает число элементов
последовательности.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">ПолучитьСвойство(&lt;Индекс&gt;)</span> –
возвращает свойство, которому соответствует значение, находящееся по индексу <span class="Term">Индекс</span>. Если <span class="Term">Индекс</span> находится за границами допустимых
значений, выдается исключение. Метод может вернуть неопределенное значение,
если элементу последовательности соответствует фрагмент текста из смешанного
содержания (текст и элементы).</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">ПолучитьЗначение(&lt;Индекс&gt;)</span> –
возвращает значение, находящееся по индексу <span class="Term">Индекс</span>. Если <span class="Term">Индекс</span> находится за границами допустимых
значений, выдается исключение.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">УстановитьЗначение(&lt;Индекс&gt;, &lt;Элемент&gt;)</span> –
устанавливает значение <span class="Term">Элемент</span>
по индексу <span class="Term">Индекс</span>.
<span class="Term">Индекс</span>
должен иметь значение в диапазоне допустимых индексов. Элемент должен иметь
допустимое значение для свойства, для которого он устанавливается, или для текста.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Добавить(&lt;Свойство&gt;, &lt;Элемент&gt;)</span> –
добавляет пару «свойство – значение» к последовательности. Значение должно
быть допустимым для свойства.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Добавить(&lt;Текст&gt;)</span> – добавляет
фрагмент текста к последовательности. Если у типа объекта свойство <span class="Term">Смешанный</span> имеет значение <span class="Term">Ложь</span>, то выдается исключение.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Вставить(&lt;Индекс&gt;, &lt;Свойство&gt;, &lt;Элемент&gt;)</span> –
вставляет пару «свойство – значение» в позицию <span class="Term">Индекс</span> последовательности. <span class="Term">Индекс</span> должен иметь значение внутри диапазона
индексов. Элемент в позиции <span class="Term">Индекс</span>
и все элементы с большими значениями индекса сдвигаются вправо на одну позицию.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Вставить(&lt;Индекс&gt;, &lt;Текст&gt;)</span> –
вставляет текст <span class="Term">Текст</span>
в позицию <span class="Term">Индекс</span>
последовательности. <span class="Term">Индекс</span>
должен иметь значение внутри диапазона индексов. Элемент в позиции <span class="Term">Индекс</span> и все элементы с большими значениями
индекса сдвигаются вправо на одну позицию.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
<span class="Term">Удалить(&lt;Индекс&gt;)</span> – удаляет элемент
последовательности в позиции <span class="Term">Индекс</span>.
<span class="Term">Индекс</span>
должен иметь значение внутри диапазона допустимых.</p>

<a id="TI000000773" class="bookmark" name="issogl3_16.1.4.4_список_xdto"><h4>16.1.4.4. Список XDTO</h4></a>

<p class="MsoNormalCxSpFirst">С
помощью объекта <span class="Term">СписокXDTO</span>
моделируется список значений для свойств с множественными значениями (<span class="Term">ВерхняяГраница &gt; 1</span>). Список представляет
собой упорядоченный набор объектов, которые могут являться как значениями XDTO,
так и объектами XDTO. Среди них могут иметь место неопределенные значения, если
свойство <span class="Term">ВозможноПустое</span>
имеет значение <span class="Term">Истина</span>.
Но понятие «установленности» для элемента списка не определено.</p>

<p class="MsoNormalCxSpLast">Объект
<span class="Term">СписокXDTO</span>
содержит следующие методы:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
<span class="Term">Количество()</span> – возвращает размер списка.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Получить(&lt;Индекс&gt;)</span> – получает
значение, находящееся по индексу <span class="Term">Индекс</span>.
<span class="Term">Индекс</span>
должен находиться в диапазоне допустимых. В противном случае выдается исключение.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Установить(&lt;Индекс&gt;, &lt;Элемент&gt;)</span> –
устанавливает значение <span class="Term">Элемент</span>
в позицию <span class="Term">Индекс</span>.
Устанавливаемое значение замещает ранее присутствовавшее значение. <span class="Term">Индекс</span> должен находиться в диапазоне допустимых,
а <span class="Term">Элемент</span>
должен быть допустимым для свойства. В противном случае выдается исключение.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Добавить(&lt;Элемент&gt;)</span> – добавляет
значение в хвост списка. <span class="Term">Элемент</span>
должен быть допустимым для свойства. В противном случае выдается исключение.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Вставить(&lt;Индекс&gt;, &lt;Элемент&gt;)</span> –
внесение значения <span class="Term">Элемент</span>
в позицию <span class="Term">Индекс</span>.
<span class="Term">Индекс</span>
должен находиться в диапазоне допустимых, а <span class="Term">Элемент</span> должен быть допустимым для свойства. В
противном случае выдается исключение. Значение в позиции <span class="Term">Индекс</span> и значения с большими позициями сдвигаются
вправо на одну позицию.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
<span class="Term">Удалить(&lt;Индекс&gt;)</span> – удаление
значения в позиции <span class="Term">Индекс</span>.
<span class="Term">Индекс</span>
должен находиться в диапазоне допустимых. Значения с большими позициями сдвигаются
на освободившееся место.</p>

<a id="TI000000774" class="bookmark" name="issogl3_16.1.4.5_xрath"><h4>16.1.4.5. XРath</h4></a>

<p class="MsoNormalCxSpFirst">Для
навигации по дереву объектов могут использоваться выражения на XPath. Строго
говоря, это не совсем XPath, а скорее несколько модифицированное подмножество XPath.</p>

<p class="MsoNormalCxSpMiddle">Основной
конструкцией данного языка является путь к значению, который состоит из отдельных
шагов. Шаги в пути отделяются друг от друга символами &quot;<span class="Interface">/</span>&quot; (слеш).
В качестве шага пути выступает имя свойства или предопределенные конструкции &quot;<span class="Interface">.</span>&quot; (точка)
и &quot;<span class="Interface">..</span>&quot; (две точки).</p>

<p class="MsoNormalCxSpLast">Выражение
приведенного ниже вида обозначает свойство с именем <span class="Term">ИмяСвойства</span> текущего объекта, а именно объекта,
у которого вызвали метод <span class="Term">Получить()</span>
или <span class="Term">Установить()</span>.</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">ИмяСвойства</pre>

<p class="MsoNormal">Выражение
приведенного ниже вида означает, что у текущего объекта получено значение
свойства <span class="Term">ИмяСвойства1</span>,
а у объекта, ссылка на который является значением свойства <span class="Term">ИмяСвойства1</span>, получено свойство <span class="Term">ИмяСвойства2</span>.</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">ИмяСвойства1/ИмяСвойства2</pre>

<p class="MsoNormalCxSpFirst">Соответственно,
шаг, обозначенный как точка, означает текущий объект, а две точки –
объект-владелец текущего.</p>

<p class="MsoNormalCxSpMiddle">Если
путь поиска начинается с символа слеш, то это означает поиск от корня дерева
объектов. Если какое-либо свойство в пути не найдено, то это вызывает
исключение. Если в пути встречается свойство с множественным значением, то результатом
является весь список значений данного свойства.</p>

<p class="MsoNormalCxSpLast">Например,
если в пути, приведенном ниже, свойство <span class="Term">Список</span> имеет множественное значение, то
результат данного выражения – это список (<span class="Term">СписокXDTO</span>) значений данного свойства.</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">Свойство/Список</pre>

<p class="MsoNormal">Для
того чтобы получить отдельное значение из этого списка, нужно через точку от
имени свойства указать 0-базированный индекс значения в списке, как это показано
ниже.</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">Свойство/Список.0</pre>

<p class="MsoNormalCxSpFirst">Индекс
должен быть задан как целое число, находящееся в пределах диапазона допустимых
индексов. В противном случае будет вызвано исключение.</p>

<p class="MsoNormalCxSpLast">Можно
получить отдельное значение из списка с использованием 1-базированного индекса.
Для этого применяется конструкция следующего вида:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">Свойство/Список[1]</pre>

<p class="MsoNormalCxSpFirst">Индекс
может принимать значения от 1 до числа элементов в списке.</p>

<p class="MsoNormalCxSpLast">Имеется
также возможность поиска в списке (только для объектов). Выражение для поиска
выглядит следующим образом:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">Свойство/Список[ИмяСвойства='СтрокаПоиска']</pre>

<p class="MsoNormal">Здесь
<span class="Term">Список</span> –
это свойство с множественным значением. Значением списка являются объекты, у
которых имеется свойство с именем <span class="Term">ИмяСвойства</span>.
Результатом будет первый объект в списке, значение свойства <span class="Term">Свойство</span> которого равно строковому значению <span class="Interface">‘СтрокаПоиска’</span>.
Если ни одного объекта не найдено, то результатом является неопределенное
значение. Свойство <span class="Term">ИмяСвойства</span>
также может присутствовать не у всех объектов в списке. А может и не присутствовать
ни у кого. Значение, с которым сравнивается значение свойства, может быть
задано в виде числа, логического значения (<span class="Term">True</span> или <span class="Term">False</span>) или строкового литерала.</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">Свойство/Список[ИмяСвойства!='СтрокаПоиска']</pre>

<p class="MsoNormalCxSpFirst">Приведенное
выше выражение аналогично предыдущему примеру, за исключением того, что
результатом будет первый объект в списке, значение свойства <span class="Term">ИмяСвойства</span> которого не равно строковому
значению <span class="Interface">‘СтрокаПоиска’</span>.</p>

<p class="MsoNormalCxSpLast">Ниже
приведено определение описываемого подмножества XPath.</p>

<p class="Lang-subheader">&lt;Путь&gt;</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">[/] &lt;Список шагов&gt;</pre>

<p class="Lang-subheader">&lt;Список
шагов&gt;</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">&lt;Шаг&gt; [/&lt;Список шагов&gt;] |</pre>

<p class="Lang-subheader">&lt;Шаг&gt;</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">&lt;Имя свойства&gt; [&lt;Уточнение&gt;] | .. | . |</pre>

<p class="Lang-subheader">&lt;Имя
свойства&gt;</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">[&lt;Буква&gt; | _]&lt;Остаток имени&gt;</pre>

<p class="Lang-subheader">&lt;Остаток
имени&gt;</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">{&lt;Буква&gt; | &lt;Цифра&gt; | _} &lt;Остаток имени&gt; |</pre>

<p class="Lang-subheader">&lt;Уточнение&gt;</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
.&lt;0-базированный индекс&gt; |
[&lt;Имя свойства&gt;=&lt;Значение&gt;] |
[&lt;Имя свойства&gt;!=&lt;Значение&gt;] |
[&lt;1-базированный индекс&gt;]
</pre>

<p class="Lang-subheader">&lt;0-базированный
индекс&gt;</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">&lt;Целое без знака&gt;</pre>

<p class="Lang-subheader">&lt;1-базированный
индекс&gt;</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">&lt;Целое без знака&gt;</pre>

<p class="Lang-subheader">&lt;Целое
без знака&gt;</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">&lt;Цифра&gt; &lt;Цифры&gt;</pre>

<p class="Lang-subheader">&lt;Цифра&gt;</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</pre>

<p class="Lang-subheader">&lt;Цифры&gt;</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">&lt;Цифра&gt; &lt;Цифры&gt; |</pre>

<p class="Lang-subheader">&lt;Значение&gt;</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">&lt;Число&gt; | &lt;Строка&gt; | &lt;Булево&gt;</pre>

<p class="Lang-subheader">&lt;Число&gt;</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">[+|-]&lt;Целое без знака&gt;[.&lt;Целое без знака&gt;]</pre>

<p class="Lang-subheader">&lt;Строка&gt;</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">&quot;&lt;Символы&gt;&quot; | '&lt;Символы&gt;'</pre>

<p class="Lang-subheader">&lt;Булево&gt;</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">true | false</pre>

<p class="Note"><span class="Note">Примечание.</span> В строке с ограничителями «<span class="Interface">&quot;</span>» среди
символов не может встречаться «<span class="Interface">&quot;</span>». Аналогично в строке с разделителями
«<span class="Interface">’</span>» не может встречаться символ «’».</p>

<p class="MsoNormal">При
сравнении значения свойства со значением, заданным в виде литерала, значение,
заданное в виде литерала, приводится к типу свойства по правилам приведения,
после чего производится сравнение.</p>

<a id="TI000000775" class="bookmark" name="issogl2_16.1.5_xml-сериализация_на_основе_xdto"><h3>16.1.5. XML-сериализация на основе XDTO</h3></a>

<p class="MsoNormalCxSpFirst">Значения
типов конфигураций системы «1С:Предприятие» могут быть сериализованы
непосредственно в(из) файл(а) XML на основе XDTO.</p>

<p class="MsoNormalCxSpMiddle">Для
этого используется объект <span class="Term">СериализаторXDTO</span>,
который может быть получен с помощью конструктора на основе существующей
фабрики XDTO. Работа с объектом <span class="Term">СериализаторXDTO</span>
аналогична работе с глобальными процедурами и функциями работы с XML.</p>

<p class="MsoNormalCxSpLast">Например,
сериализация ссылки на справочник <span class="Term">Номенклатура</span>
в файл XML может быть выполнена с помощью программного кода.</p>

<p class="Lang-subheader">Пример:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev"><span class="comment">// Получить ссылку на элемент справочника Номенклатура</span>
СсылкаНаЭлементСправочника <span class="operator">=</span> Справочники<span class="operator">.</span>Номенклатура<span class="operator">.</span>НайтиПоКоду<span class="operator">(</span><span class="string">&quot;0000001&quot;</span><span class="operator">)</span><span class="operator">;</span>
<span class="comment">// Создать сериализатор XDTO для глобальной фабрики XDTO</span>
НовыйСериализаторXDTO <span class="operator">=</span> <span class="keyword">Новый</span> СериализаторXDTO<span class="operator">(</span>ФабрикаXDTO<span class="operator">)</span><span class="operator">;</span>
<span class="comment">// Создать объект записи XML и открыть файл</span>
НоваяЗаписьXML <span class="operator">=</span> <span class="keyword">Новый</span> ЗаписьXML<span class="operator">;</span>
НоваяЗаписьXML<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;D:/Exchange.xml&quot;</span><span class="operator">)</span><span class="operator">;</span>
<span class="comment">// ...</span>
<span class="comment">// Cериализовать ссылку в XML</span>
НовыйСериализаторXDTO<span class="operator">.</span>ЗаписатьXML<span class="operator">(</span>НоваяЗаписьXML<span class="operator">,</span> СсылкаНаЭлементСправочника<span class="operator">,</span> НазначениеТипаXML<span class="operator">.</span>Явное<span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">Ниже
приведен пример сериализации ссылки на справочник <span class="Term">Номенклатура</span> из файла XML.</p>

<p class="Lang-subheader">Пример:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev"><span class="comment">// Создать сериализатор XDTO для глобальной фабрики XDTO</span>
НовыйСериализаторXDTO <span class="operator">=</span> <span class="keyword">Новый</span> СериализаторXDTO<span class="operator">(</span>ФабрикаXDTO<span class="operator">)</span><span class="operator">;</span>
<span class="comment">// Прочитать данные объекта XDTO из файла XML</span>
НовоеЧтениеXML <span class="operator">=</span> <span class="keyword">Новый</span> ЧтениеXML<span class="operator">;</span>
НовоеЧтениеXML<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;D:/Exchange.xml&quot;</span><span class="operator">)</span><span class="operator">;</span>
…
<span class="comment">// Сериализовать ссылку из XML    </span>
НоваяСсылкаНаСправочник <span class="operator">=</span> НовыйСериализаторXDTO<span class="operator">.</span>ПрочитатьXML<span class="operator">(</span>НовоеЧтениеXML<span class="operator">)</span><span class="operator">;</span></pre>

<a id="TI000000776" class="bookmark" name="issogl2_16.1.6_рекомендации_по_оформлению_схем_xml"><h3>16.1.6. Рекомендации по оформлению схем XML</h3></a>

<p class="MsoNormal">Преобразование
<span class="Term">НаборСхемXML</span>
&quot;
<span class="Term">ФабрикаXDTO</span>
&quot;
<span class="Term">НаборСхемXML</span>
в общем случае не дает на выходе набор схем XML, эквивалентный исходному.
Однако следование набору рекомендаций по оформлению схем XML позволит добиться
эквивалентности выходного набора схем исходному, а именно:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
для преобразования <span class="Term">НаборСхемXML</span> &quot; <span class="Term">ФабрикаXDTO</span> &quot;
<span class="Term">НаборСхемXML</span>
будет соблюдаться эквивалентность выходного набора схем исходному;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
успешная проверка правильности заполнения
свойств объекта <span class="Term">ОбъектXDTO</span>
(метод <span class="Term">Проверить()</span>)
гарантирует, что представление объекта в XML будет соответствовать схеме XML;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
обеспечивается максимальная гибкость и
отсутствие искажений при использовании полиморфизма.</p>

<p class="MsoNormalCxSpFirst">Схема
XML, полученная на основе фабрики XDTO, для типов которой не переопределялись
значения по умолчанию параметров, ответственных за XML-представление данных,
безусловно, соответствует приведенным рекомендациям.</p>

<p class="MsoNormalCxSpLast">В
общем, приведенный далее список рекомендаций представляет собой набор правил,
позволяющий добиться наилучших результатов с различных точек зрения.</p>

<p class="Lang">Схема
XML не должна содержать анонимных типов</p>

<p class="MsoNormal">Недопустимы
конструкции следующего вида:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
&lt;element name=&quot;Person&quot;&gt;
    &lt;complexType&gt;
        &lt;sequence&gt;
            &lt;element name=&quot;FirstName&quot; type=&quot;string&quot; /&gt;
            &lt;element name=&quot;FamilyName&quot; type=&quot;string&quot; /&gt;
        &lt;/sequence&gt;
    &lt;/complexType&gt;
&lt;/element&gt;
</pre>

<p class="MsoNormal">Этот
фрагмент нужно оформить следующим образом:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
&lt;element name=&quot;Person&quot; type=&quot;tns:PersonType&quot;&gt;
    &lt;complexType name=&quot;PersonType&quot;&gt;
        &lt;sequence&gt;
            &lt;element name=&quot;FirstName&quot; type=&quot;string&quot; /&gt;
            &lt;element name=&quot;FamilyName&quot; type=&quot;string&quot; /&gt;
        &lt;/sequence&gt;
    &lt;/complexType&gt;
&lt;/element&gt;
</pre>

<p class="Lang">Для контента сложных типов следует
использовать только модель sequence</p>

<p class="MsoNormal">Для
моделирования контента у сложных типов (<span class="Term">complexType</span>) следует использовать только
единственный блок <span class="Term">sequence</span>
без переопределения значений по умолчанию атрибутов <span class="Term">minOccurs</span> и <span class="Term">maxOccurs</span>.</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
&lt;complexType name=&quot;PersonType&quot;&gt;
    &lt;sequence&gt;
        &lt;element name=&quot;FirstName&quot; type=&quot;string&quot; /&gt;
        &lt;element name=&quot;FamilyName&quot; type=&quot;string&quot; /&gt;
    &lt;/sequence&gt;
&lt;/complexType&gt;
</pre>

<p class="MsoNormalCxSpFirst">Модель
<span class="Term">all</span>
не нарушает тождественность исходной и результирующей схемы при преобразовании <span class="Term">НаборСхемXML</span> &quot;
<span class="Term">ФабрикаXDTO</span>
&quot;
<span class="Term">НаборСхемXML</span>,
однако имеет ряд ограничений. В частности, значение атрибута <span class="Term">maxOccurs</span> для элементов в модели <span class="Term">all</span> не может быть больше 1.</p>

<p class="MsoNormalCxSpMiddle">Модель
<span class="Term">choice</span>
нарушает эквивалентность исходной и результирующей схем и не позволяет с
помощью метода <span class="Term">Проверить()</span>
проверить соответствие заполнения данных объекта схеме XML.</p>

<p class="MsoNormalCxSpLast">По
тем же причинам не следует использовать в рамках одного сложного типа
комбинацию из нескольких моделей контента или же определять для <span class="Term">sequence</span> значения атрибутов <span class="Term">minOccurs</span> и <span class="Term">maxOccurs</span>, отличные от значений по умолчанию.</p>

<p class="Lang">Желательно
свойства объектов представлять в XML в виде элементов</p>

<p class="MsoNormal">Представление
свойств как атрибутов XML не влияет на эквивалентность исходной и
результирующей схем. Однако имеется ряд ограничений:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
В атрибуте не может быть представлено значение
объектного типа – только типов-значений.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
В атрибуте не могут быть представлены свойства с
множественными значениями.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
В случае полиморфных типов у свойства, представленного
как атрибут XML, может происходить искажение типа значения. А именно: при
присваивании значения свойству тип значения приводится точно к типу свойства,
так как только для значения свойства в элементе XML можно указать атрибут <span class="Interface">xsi:type</span>, который
позволяет точно указать тип значения свойства.</p>

<p class="MsoNormalCxSpFirst">Как
следствие не нужно использовать <span class="Term">simpleContent</span>
для <span class="Term">complexType</span>,
так как эта модель для хранения значений подразумевает использование свойств
атрибутов и текста включающего элемента XML.</p>

<p class="MsoNormalCxSpLast">Не
рекомендуется использовать одинаковые имена для объявления атрибута и элемента.
Правила формирования имени свойства XDTO см. <a href="#_ref342389685">здесь</a>.</p>

<p class="Lang">Не
следует использовать модель mixed content</p>

<p class="MsoNormal">Применение
в схеме XML конструкции приведенного ниже вида означает, что в элементе XML,
соответствующем описываемому типу, текст может быть перемешан с элементами XML.</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
&lt;complexType name=&quot;FormLetter&quot; mixed=&quot;true&quot;&gt;
&lt;/complexType&gt;
</pre>

<p class="MsoNormalCxSpFirst">Для
поддержки такого информационного содержимого у соответствующего объекта <span class="Term">ТипОбъектаXDTO</span> значения свойств <span class="Term">Последовательный</span> и <span class="Term">Смешанный</span> установлены в значение <span class="Term">Истина</span>, а у каждого экземпляра соответствующего
объекта <span class="Term">ОбъектXDTO</span>
появляется последовательность XDTO (объект <span class="Term">ПоследовательностьXDTO</span>). Управление информационным
содержимым таких объектов намного сложнее, чем у объектов, состояние которых
представлено только набором значений свойств.</p>

<p class="MsoNormalCxSpMiddle">К
счастью, в подавляющем большинстве случаев в применении <span class="Term">mixed content</span> не возникает необходимости.</p>

<p class="MsoNormalCxSpMiddle">Свойство
<span class="Term">ФормаЭлементовПоУмолчанию</span>
у схемы XML должно иметь значение <span class="Term">Квалифицированная</span>.</p>

<p class="MsoNormalCxSpLast">Данная
рекомендация является элементом хорошего стиля, и XDTO придерживается этого
стиля.</p>

<a name="_ref225333475"></a><a id="TI000000777" class="bookmark" name="issogl2_16.1.7_правила_проверки_фабрики_xdto"><h3>16.1.7. Правила проверки фабрики XDTO</h3></a>

<p class="MsoNormal">Общая
схема кодирования идентификаторов сообщений об ошибках проверки фабрики XDTO
выглядит следующим образом:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">xdto-&lt;область&gt;-&lt;раздел&gt;[-&lt;правило&gt;]: &lt;описание ошибки&gt;</pre>

<p class="MsoListBulletCxSpFirst">&#9679; 
<span class="Interface">&lt;область&gt;</span> –
область проверки (фабрика XDTO, пакет XDTO, тип значения XDTO, фасет XDTO, тип
объекта XDTO);</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Interface">&lt;раздел&gt;</span> –
номер раздела, проверка правила которого завершилась неудачей;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Interface">&lt;правило&gt;</span> –
правило раздела;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
<span class="Interface">&lt;описание ошибки&gt;</span> –
описание ошибки.</p>

<a id="TI000000778" class="bookmark" name="issogl3_16.1.7.1_правила_проверки_непосредственно_фабрики_xdto"><h4>16.1.7.1. Правила проверки непосредственно фабрики XDTO</h4></a>

<p class="MsoNormal">При
проверке непосредственно фабрики XDTO ошибки кодируются префиксом <span class="Term">model</span>. При этом общий префикс будет иметь следующий
вид:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">xdto-model-&lt;раздел&gt;[-&lt;правило&gt;]: &lt;описание ошибки&gt;</pre>

<p class="MsoNormalCxSpFirst">Пакеты,
входящие в модель, должны иметь уникальные URI пространства имен –
дублирование пакетов в рамках модели запрещено.</p>

<p class="MsoNormalCxSpMiddle">Директива
импорта должна определять непустое URI пространства имен импортируемого пакета.</p>

<p class="MsoNormalCxSpMiddle">Директивы
импорта пакетов должны определять существующие пакеты типов.</p>

<p class="MsoNormalCxSpLast">Пакеты
типов, определенные в модели, должны удовлетворять правилам проверки пакетов.</p>

<a id="TI000000779" class="bookmark" name="issogl3_16.1.7.2_правила_проверки_пакета_xdto"><h4>16.1.7.2. Правила проверки пакета XDTO</h4></a>

<p class="MsoNormal">При
проверке правильности пакета XDTO ошибки кодируются префиксом <span class="Term">package</span>. При этом общий префикс будет иметь следующий
вид:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">xdto-package-&lt;раздел&gt;[-&lt;правило&gt;]: &lt;описание ошибки&gt;</pre>

<p class="MsoNormalCxSpFirst">Пакет
XDTO должен иметь установленное свойство <span class="Term">URIПространстваИмен</span>.</p>

<p class="MsoNormalCxSpMiddle">Типы,
определяемые в пакете XDTO, могут иметь ссылки только на типы, указанные в
списке импортируемых (свойство <span class="Term">Зависимости</span>).</p>

<p class="MsoNormalCxSpLast">Директивы импорта должны удовлетворять следующим правилам:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
директивы импорта должны определять пакеты XDTO,
в которых не могут содержаться директивы импорта, указывающие на данный пакет XDTO, –
зацикливание импортируемых директив не допускается;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
директива импорта должна определять не пустое
свойство <span class="Term">URIПространстваИмен</span>
импортируемого пакета XDTO;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
директивы импорта должны определять существующие
пакеты XDTO.</p>

<p class="MsoNormal">Свойства
пакета должны удовлетворять следующим правилам:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
имена свойств пакета должны быть установлены и
не являться пустыми;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
имена свойств пакета должны быть уникальны в
пределах пакета;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
тип свойства пакета должен быть установлен или
определен;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
типы свойств пакета должны быть определены в пакете
или его зависимостях;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
задание одновременно имени типа глобального свойства
и анонимного определения типа глобального свойства недопустимо;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
свойство пакета не должно ссылаться на
определение другого свойства пакета;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
свойство пакета не должно определять границы количества
значений свойства;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
свойство пакета может иметь форму представления
только <span class="Term">Атрибут</span>
или <span class="Term">Элемент</span>.</p>

<a id="TI000000780" class="bookmark" name="issogl3_16.1.7.3_правила_проверки_типа_значения_xdto"><h4>16.1.7.3. Правила проверки типа значения XDTO</h4></a>

<p class="MsoNormal">При
проверке правильности типа значения XDTO ошибки кодируются префиксом <span class="Term">valueType</span>. При этом общий префикс будет иметь
следующий вид:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">xdto-valueType-&lt;раздел&gt;[-&lt;правило&gt;]: &lt;описание ошибки&gt;</pre>

<p class="MsoListBulletCxSpFirst">&#9679; 
Общие правила проверки типа значения XDTO:</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
если тип определен в рамках пакета типов, то
должны выполняться следующие условия:</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
тип значения XDTO должен иметь установленное
свойство <span class="Term">Имя</span>,
содержащее непустое имя;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
имя типа значения XDTO должно быть уникальным в
пределах пакета XDTO (среди всех типов пакета XDTO);</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
если тип определен в рамках другого определения
типа значения или в рамках определения свойства объектного типа, то должно
выполняться следующее условие:</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
свойство <span class="Term">Имя</span> определения типа не должно быть
установлено;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
тип значения XDTO не может содержать ссылок на
самого себя ни в базовом типе, ни в типе элемента списка, ни в одном из типов
объединения на всю глубину иерархии.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
Правила проверки базового типа – свойство <span class="Term">БазовыйТип</span>:</p>

<p class="MsoListBullet2">&#9679; 
если свойство <span class="Term">БазовыйТип</span> не установлено:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
если свойство <span class="Term">Вариант</span> не установлено, а свойство <span class="Term">ТипыЧленовОбъединения</span> не установлено, или
свойство <span class="Term">Вариант</span>
установлено и имеет значение <span class="Term">Атомарный</span>:</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
если свойство <span class="Term">ОпределениеТипа</span> содержит единственное
значение, то это определение типа является определением анонимного базового
типа;</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
в противном случае базовым типом считается тип <span class="Term">anySimpleType</span> пространства имен XML-схемы (<a href="http://www.w3.org/2001/XMLSchema" target="_blank">http://www.w3.org/2001/XMLSchema</a>);</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
если свойство <span class="Term">БазовыйТип</span> определения типа установлено, то
должны выполняться следующие условия:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
базовый тип должен удовлетворять второму правилу
проверки пакета XDTO;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
базовый тип должен являться типом значения XDTO;</p>

<p class="MsoListBullet2">&#9679; 
базовый тип не может являться данным типом значения
XDTO.</p>

<p class="MsoListBullet">&#9679; 
Правила проверки типа элемента списка –
свойство <span class="Term">ТипЭлементаСписка</span>:</p>

<p class="MsoListBullet2">&#9679; 
если свойство <span class="Term">ТипЭлементаСписка</span> определения типа
установлено, то должны выполняться следующие условия:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
тип элемента списка должен удовлетворять второму
правилу проверки пакета XDTO;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
тип элемента списка должен являться типом
значения XDTO;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
тип элемента списка не может являться данным
типом значения XDTO;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
тип значения XDTO, являющийся элементом списка,
должен быть либо атомарным, либо объединением типов значений XDTO, состоящим
только из атомарных типов значений XDTO;</p>

<p class="MsoListBullet2">&#9679; 
если свойство <span class="Term">Вариант</span> не установлено, а свойство <span class="Term">БазовыйТип</span> установлено или свойство <span class="Term">Вариант</span> установлено и имеет значение <span class="Term">Список</span>:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
если свойство <span class="Term">ОпределениеТипа</span> содержит единственное
значение, то это определение типа является определением анонимного типа
элемента списка;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
в противном случае значение свойства <span class="Term">ТипЭлементаСписка</span> определяется из
соответствующего свойства базового типа значения XDTO.</p>

<p class="MsoListBullet">&#9679; 
Правила проверки типа объединения –
свойство <span class="Term">ТипыЧленовОбъединения</span>:</p>

<p class="MsoListBullet2">&#9679; 
если свойство <span class="Term">ТипыЧленовОбъединения</span> определения типа XDTO
установлено, то должны выполняться следующие условия:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
тип объединения должен удовлетворять второму
правилу проверки пакета XDTO;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
тип объединения должен являться типом значения
XDTO;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
тип объединения не должен являться данным типом
значения XDTO;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
тип значения XDTO, являющийся объединением,
должен быть либо атомарным, либо списком;</p>

<p class="MsoListBullet2">&#9679; 
если свойство <span class="Term">Вариант</span> не установлено, а свойство <span class="Term">БазовыйТип</span> установлено или свойство <span class="Term">Вариант</span> установлено и имеет значение <span class="Term">Объединение</span>:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
свойство <span class="Term">ОпределениеТипа</span> содержит значения, являющиеся
анонимными определениями типов объединения;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
в противном случае значение свойства <span class="Term">ТипыЧленовОбъединения</span> определяется значением
свойства <span class="Term">ТипыЧленовОбъединения</span>
базового типа значения XDTO.</p>

<p class="MsoListBullet">&#9679; 
Наследование типов значений XDTO считается правильным,
если выполнятся следующие условия:</p>

<p class="MsoListBullet2">&#9679; 
для атомарных типов значений XDTO (после
выполнения правил проверки типа элемента списка и правил проверки типа
объединения свойства <span class="Term">ТипЭлементаСписка</span>
и <span class="Term">ТипыЧленовОбъединения</span>
не установлены) должны выполняться следующие условия:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
тип значения XDTO, являющийся базовым, должен
быть атомарным, т. е. свойства <span class="Term">ТипЭлементаСписка</span> и <span class="Term">ТипыЧленовОбъединения</span> базового типа XDTO не
должны быть установлены;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
предком типа значения XDTO должен быть один из
примитивных типов пространства имен схемы XML (<span class="Interface">http://www.w3.org/2001/XMLSchema</span>);</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
состав фасетов, установленных в описании типа
значения XDTO, должен соответствовать списку допустимых фасетов для
примитивного типа, являющегося предком данного типа XDTO;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
значение каждого фасета, установленного в типе
значения XDTO, должно удовлетворять правилам ограничения эффективного значения
аналогичного фасета базового типа XDTO;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
для типов элемента списка (после выполнения
правил проверки типа элемента списка и правил проверки типа объединения
установлено свойство <span class="Term">ТипЭлементаСписка</span>):</p>

<p class="MsoListBullet4CxSpFirst">&#9679; 
базовый тип XDTO не может являться типом
объединения, т. е. свойство <span class="Term">ТипыЧленовОбъединения</span> базового типа XDTO не
должно быть установлено;</p>

<p class="MsoListBullet4CxSpLast">&#9679; 
если свойство <span class="Term">ТипЭлементаСписка</span> базового типа XDTO
установлено, то значение этого свойства должно определять базовый тип для типа
элемента списка, определенного в свойстве <span class="Term">ТипЭлементаСписка</span> данного типа значения XDTO;</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
если базовым типом является тип <span class="Term">anySimpleType</span> пространства имен XML схемы (<span class="Interface">http://www.w3.org/2001/XMLSchema</span>),
то среди списка фасетов допускается только фасет <span class="Term">ПробельныеСимволы</span>;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
в противном случае могут быть определены только
фасеты: <span class="Term">Образец</span>,
<span class="Term">Перечисление</span>,
<span class="Term">Длина</span>,
<span class="Term">МинДлина</span>,
<span class="Term">МаксДлина</span>
и <span class="Term">ПробельныеСимволы</span>;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
значение каждого фасета, установленного в типе,
должно удовлетворять правилам ограничения эффективного значения аналогичного
фасета базового типа;</p>

<p class="MsoListBullet2">&#9679; 
для типов объединения (после выполнения правил
проверки типа элемента списка и правил проверки типа объединения установлено
свойство <span class="Term">ТипыЧленовОбъединения</span>):</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
базовым типом может являться тип <span class="Term">anySimpleType</span> пространства имен XML схемы (<span class="Interface">http://www.w3.org/2001/XMLSchema</span>)
или тип объединения, т. е. у базового типа должно быть установлено
свойство <span class="Term">ТипыЧленовОбъединения</span>;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
если базовым типом является тип объединения,
должны выполняться следующие условия:</p>

<p class="MsoListBullet4CxSpFirst">&#9679; 
количество типов объединения базового типа не
должно быть больше количества типов объединения данного типа;</p>

<p class="MsoListBullet4CxSpMiddle">&#9679; 
типы объединения должны быть потомками
соответствующих им типов объединения базового типа в порядке следования в
списке типов объединения;</p>

<p class="MsoListBullet4CxSpLast">&#9679; 
если базовым типом является тип <span class="Term">anySimpleType</span> пространства имен XML схемы (<span class="Interface">http://www.w3.org/2001/XMLSchema</span>),
то определение фасетов не допускается;</p>

<p class="MsoListBullet3">&#9679; 
в противном случае могут быть определены только
фасеты <span class="Term">Образец</span>
и <span class="Term">Перечисление</span>;</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
значение каждого фасета, установленного в типе,
должно удовлетворять правилам ограничения эффективного значения аналогичного
фасета базового типа.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
Если свойство <span class="Term">Вариант</span> (модель содержания) определения типа
установлено, то оно не должно противоречить определению типа:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
если свойство имеет значение <span class="Term">Атомарный</span>, то тип имеет атомарную модель
содержания и должен удовлетворять правилам <span class="Interface">xdto-valueType-5.1</span>;</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
если свойство имеет значение <span class="Term">Список</span>, то тип имеет модель содержания <span class="Term">Список</span> и должен удовлетворять правилам <span class="Interface">xdto-valueType-5.2</span>;</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
если свойство имеет значение <span class="Term">Объединение</span>, то тип имеет модель содержания <span class="Term">Объединение</span> и должен удовлетворять правилам <span class="Interface">xdto-valueType-5.3</span>.</p>

<p class="MsoNormal"> </p>

<a id="TI000000781" class="bookmark" name="issogl3_16.1.7.4_правила_проверки_типа_объекта_xdto"><h4>16.1.7.4. Правила проверки типа объекта XDTO</h4></a>

<p class="MsoNormal">При проверке правильности типа объекта XDTO
ошибки кодируются префиксом <span class="Term">objectType</span>.
При этом общий префикс будет иметь следующий вид:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">xdto-objectType-&lt;раздел&gt;[-&lt;правило&gt;]: &lt;описание ошибки&gt;</pre>

<p class="MsoListBullet">&#9679; 
Общие правила проверки типа объекта XDTO:</p>

<p class="MsoListBullet2">&#9679; 
если тип определен в рамках пакета типов, то
должны соблюдаться следующие условия:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
тип объекта XDTO должен иметь установленное
свойство <span class="Term">Имя</span>, содержащее
непустое имя;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
имя типа объекта XDTO должно быть уникальным в
пределах пакета (среди всех типов пакета);</p>

<p class="MsoListBullet2">&#9679; 
если тип определен в рамках свойства объектного
типа, то должны соблюдаться следующие условия:</p>

<p class="MsoListBullet3">&#9679; 
свойство <span class="Term">Имя</span>
определения типа не должно быть установлено.</p>

<p class="MsoListBullet">&#9679; 
Правила проверки базового типа – свойство <span class="Term">БазовыйТип</span>:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
если свойство <span class="Term">БазовыйТип</span>
не установлено, то базовым типом считается тип <span class="Term">anyType</span>
пространства имен XML схемы (<span class="Interface">http://www.w3.org/2001/XMLSchema</span>);</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
если свойство <span class="Term">БазовыйТип</span>
типа объекта XDTO установлено, то должны выполняться следующие условия:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
базовый тип должен удовлетворять второму правилу
проверки пакета XDTO;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
базовый тип должен являться типом объекта XDTO;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
базовый тип не может являться данным типом
объекта XDTO.</p>

<p class="MsoListBullet">&#9679; 
Каждое свойство типа объекта XDTO должно удовлетворять
следующим правилам:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
имя свойства должно быть определено;</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
имя свойства не может быть пустым;</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
имя свойства должно быть уникальным для типа
объекта XDTO;</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
если свойство <span class="Term">Тип</span>
установлено, то должны выполняться следующие условия:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
имя типа должно определять существующий тип
объекта XDTO или тип значения XDTO;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
тип свойства должен удовлетворять второму
правилу проверки пакета XDTO;</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
свойство не может содержать определение анонимного
типа;</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
если свойство <span class="Term">Тип</span>
не установлено, то должны выполняться следующие условия:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
если у свойства имеется определение анонимного
типа, то типом свойства является тип, соответствующий данному определению;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
в противном случае типом свойства считается тип <span class="Term">anyType</span>
пространства имен XML схемы (<span class="Interface">http://www.w3.org/2001/XMLSchema</span>);</p>

<p class="MsoListBullet2">&#9679; 
если у свойства определено значение по умолчанию,
то должны быть выполнены следующие условия:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
тип свойства <span class="Term">ЗначениеПоУмолчанию</span>
должен быть типом значения XDTO;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
лексическое представление значения по умолчанию
должно соответствовать пространству значений типа свойства XDTO;</p>

<p class="MsoListBullet2">&#9679; 
удовлетворять следующим требованиям:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
если свойство <span class="Term">ЛокальноеИмя</span>
свойства XDTO не установлено, то в качестве локального имени XML представления
свойства XDTO используется свойство <span class="Term">Имя</span>
свойства XDTO;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
если свойство <span class="Term">URIПространстваИмен</span>
свойства XDTO не установлено, то URI пространства имен XML представления свойства
XDTO определяется следующим образом:</p>

<p class="MsoListBullet4CxSpFirst">&#9679; 
если формой XML представления свойства XDTO
(свойство <span class="Term">Форма</span>) является <span class="Term">Элемент</span>,
то используется URI пространства имен типа, которому принадлежит данное
свойство;</p>

<p class="MsoListBullet4CxSpLast">&#9679; 
в противном случае URI пространства имен
XML-представления свойства XDTO считается отсутствующим;</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
свойство XDTO должно быть уникально по XML-представлению
в пределах типа объекта XDTO;</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
если свойство XDTO имеет форму XML-представления
<span class="Term">Текст</span>, то должны выполняться следующие правила:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
имя и URI пространства имен должны быть
неустановленными или быть пустыми;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
среди свойств типа объекта XDTO допускается
наличие свойств XDTO с формой XML представления <span class="Term">Атрибут</span>;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
если свойство XDTO имеет форму XML представления
<span class="Term">Элемент</span>, то наличие среди свойств типа объекта
XDTO свойства XDTO с формой XML-представления <span class="Term">Текст</span>
запрещено;</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
значение нижней границы количества появления значений
свойства <span class="Term">НижняяГраница</span> может
принимать значения неотрицательных целых чисел. Значение нижней границы <span class="Term">НижняяГраница</span>
должно быть меньше или равно значению верхней границы количества появления
значений свойств <span class="Term">ВерхняяГраница</span>
при условии, что данное значение не равно -1;</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
значение верхней границы количества значений свойства
<span class="Term">ВерхняяГраница</span> может принимать значения неотрицательных
целых чисел или -1. Если данное значение равно -1, то это означает неограниченное
количество значений свойства;</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
если значение свойства <span class="Term">Фиксированное</span>
установлено, то по умолчанию должно быть установлено <span class="Term">ЗначениеПоУмолчанию</span>,
соответствующее пространству значений типа свойства XDTO;</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
если установлена ссылка на определение глобального
свойства, то должны выполняться следующие правила:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
определение свойства не может переопределять значения
свойств глобального определения;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
глобальное свойство, на определение которого
ссылается данное определение свойства, должно быть определено в рамках данного
пакета или пакетов-зависимостей.</p>

<p class="MsoListBullet">&#9679; 
Если среди свойств типа объекта XDTO имеется
свойство XDTO, совпадающее по имени или XML-представлению со свойством базового
типа, то вид наследования определяется как наследование ограничением. При таком
виде наследования должны выполняться следующие условия:</p>

<p class="MsoListBullet2">&#9679; 
для каждого свойства XDTO должны выполняться следующие
условия:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
в базовом типе должно быть определено свойство
XDTO с тем же именем – переопределяемое свойство;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
если базовый тип определяет порядок следования
свойств (свойство <span class="Term">Упорядоченный</span>),
то позиция переопределяемого свойства должна быть идентична позиции свойства в
типе-наследнике;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
форма XML представления переопределяемого
свойства и свойства данного типа должна совпадать;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
локальное имя XML представления переопределяемого
свойства и свойства данного типа должно совпадать;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
URI пространства имен XML представления
переопределяемого свойства и свойства данного типа должна совпадать;</p>

<p class="MsoListBullet2">&#9679; 
если переопределяемое свойство определяет фиксированное
значение, то:</p>

<p class="MsoListBullet3CxSpFirst">&#9679; 
наличие фиксированного значения не может быть
отменено в типе-наследнике;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
фиксированное значение в базовом типе и типе-наследнике
должно совпадать;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
нижняя граница количества значений свойства
должна быть меньше или равна нижней границе количества значений
переопределяемого свойства;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
верхняя граница количества значений свойства
должна быть больше или равна верхней границе количества значений
переопределяемого свойства;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
тип свойства должен являться потомком типу переопределяемого
свойства;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
если базовый тип не обладает смешанным содержанием
(свойство <span class="Term">Смешанный</span>), то
смешанная модель не может быть установлена в типе-наследнике;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
если порядок следования свойств базового типа фиксирован
(свойство <span class="Term">Упорядоченный</span>), то
порядок не может быть изменен в типе-наследнике;</p>

<p class="MsoListBullet3CxSpMiddle">&#9679; 
если базовый тип не определяет наличие последовательности
(свойство <span class="Term">Последовательный</span>),
то наличие последовательности не может быть установлено в типе-наследнике;</p>

<p class="MsoListBullet3CxSpLast">&#9679; 
если базовый тип не определяет открытую модель содержания
(свойство <span class="Term">Открытый</span>), то открытая
модель содержания не может быть установлена в типе-наследнике.</p>

<p class="MsoListBullet">&#9679; 
В противном случае вид наследования определяется
как наследование расширением. Для данного вида наследования должны выполняться
следующие правила:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
если модель содержания базового типа является
смешанной (свойство <span class="Term">Смешанный</span>),
то она не может быть изменена в типе-наследнике;</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
если порядок следования свойств базового типа не
фиксирован (свойство <span class="Term">Упорядоченный</span>),
то порядок не может быть изменен в типе-наследнике;</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
если базовый тип определяет наличие последовательности
(свойство <span class="Term">Последовательный</span>),
то последовательность не может быть запрещена в типе-наследнике;</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
если базовый тип определяет открытую модель содержания
(свойство <span class="Term">Открытый</span>), то модель
содержания не может быть изменена в типе-наследнике.</p>

<p class="MsoListBullet">&#9679; 
При любом виде наследования должны выполняться
следующие условия:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
если модель содержания является смешанной (свойство
<span class="Term">Смешанный</span>), то наличие последовательности
(свойство <span class="Term">Последовательный</span>)
не может быть запрещено;</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
если модель содержания является открытой (свойство
<span class="Term">Открытый</span>), то наличие последовательности
(свойство <span class="Term">Последовательный</span>)
не может быть запрещено.</p>

<a id="TI000000782" class="bookmark" name="issogl3_16.1.7.5_правила_ограничения_фасетов"><h4>16.1.7.5. Правила ограничения фасетов</h4></a>

<p class="MsoNormal">При
проверке правильности фасета XDTO ошибки кодируются префиксом <span class="Term">facet</span>. При этом общий префикс будет иметь
следующий вид:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">xdto-facet-&lt;раздел&gt;[-&lt;правило&gt;]: &lt;описание ошибки&gt;</pre>

<p class="MsoNormal">Правила
для фасета <span class="Term">Длина</span>:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
значение фасета должно совпадать с эффективным
значением фасета базового типа;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
если установлено значение фасета <span class="Term">МинДлина</span>, то оно должно удовлетворять
следующим условиям:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
значение фасета <span class="Term">МинДлина</span> должно быть меньше или равно значению
фасета <span class="Term">Длина</span>;</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
в базовом типе не установлено значение фасета <span class="Term">Длина</span>, или значение фасета <span class="Term">МинДлина</span> не отличается от эффективного
значения фасета <span class="Term">МинДлина</span>
базового типа;</p>

<p class="MsoListBullet">&#9679; 
если установлено значение фасета <span class="Term">МаксДлина</span>, то оно должно удовлетворять следующим
условиям:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
значение фасета <span class="Term">МаксДлина</span> должно быть меньше или равно
значению фасета <span class="Term">Длина</span>;</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
в базовом типе не установлено значение фасета <span class="Term">Длина</span>, или значение фасета <span class="Term">МаксДлина</span> не отличается от эффективного
значения фасета <span class="Term">МаксДлина</span>
базового типа.</p>

<p class="MsoNormal">Правила
для фасета <span class="Term">МинДлина</span>:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
значение фасета должно быть больше или равно эффективному
значению фасета в базовом классе;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
значение фасета должно быть меньше или равно эффективному
значению фасета <span class="Term">МаксДлина</span>.</p>

<p class="MsoNormal">Правила
для фасета <span class="Term">МаксДлина</span>:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
значение фасета должно быть меньше или равно эффективному
значению фасета в базовом классе;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
значение фасета должно быть больше или равно эффективному
значению фасета <span class="Term">МинДлина</span>.</p>

<p class="MsoNormal">Правила
для фасета <span class="Term">ПробельныеСимволы</span>:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
если эффективное значение фасета базового типа
равно <span class="Interface">collapse</span>, то значение фасета не может принимать другое
значение;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
если эффективное значение фасета базового типа
равно <span class="Interface">preserve</span>, то значение фасета не может принимать значение
<span class="Interface">replace</span>.</p>

<p class="MsoNormal">Правила
для фасета <span class="Term">МинВключающее</span>:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
значение фасета должно быть меньше эффективного
значения фасета <span class="Term">МаксИсключающее</span>
данного типа;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
значение фасета должно быть больше или равно эффективному
значению фасета базового типа;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
если установлено значение фасета <span class="Term">МаксВключающее</span>, то оно должно быть меньше или
равно эффективному значению фасета <span class="Term">МаксВключающее</span>
базового типа.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
если установлено значение фасета <span class="Term">МинИсключающее</span>, то оно должно быть больше
эффективного значения фасета <span class="Term">МинИсключающее</span>
базового типа;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
если установлено значение фасета <span class="Term">МаксИсключающее</span>, то оно должно быть меньше
эффективного значения фасета <span class="Term">МаксИсключающее</span>
базового типа.</p>

<p class="MsoNormal">Правила
для фасета <span class="Term">МинИсключающее</span>:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
установка значения фасета <span class="Term">МинИсключающее</span> и <span class="Term">МинВключающее</span> фасета в определении типа не
допускается;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
если установлено значение фасета <span class="Term">МаксВключающее</span>, то значение фасета <span class="Term">МинИсключающее</span> должно быть меньше значения
фасета <span class="Term">МаксВключающее</span>
данного типа;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
значение фасета должно быть больше или равно эффективному
значению фасета базового типа;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
если установлено значение фасета <span class="Term">МаксВключающее</span>, то оно должно быть меньше или
равно эффективному значению фасета <span class="Term">МаксВключающее</span>
базового типа;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
если установлено значение фасета <span class="Term">МинВключающее</span>, то оно должно быть больше или
равно эффективному значению фасета <span class="Term">МинВключающее</span>
базового типа;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
если установлено значение фасета <span class="Term">МаксИсключающее</span>, то оно должно быть меньше
эффективного значения фасета <span class="Term">МинВключающее</span>
базового типа.</p>

<p class="MsoNormal">Правила
для фасета <span class="Term">МаксВключающее</span>:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
значение фасета должно быть больше или равно значению
фасета <span class="Term">МинВключающее</span>
данного типа;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
если установлено значение фасета <span class="Term">МаксИсключающее</span>, то оно должно быть меньше
эффективного значения базового типа;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
если установлено значение фасета <span class="Term">МинВключающее</span>, то оно должно быть больше или
равно эффективному значению базового типа;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
если установлено значение фасета <span class="Term">МинИсключающее</span>, то оно должно быть больше
эффективного значения базового типа.</p>

<p class="MsoNormal">Правила
для фасета <span class="Term">МаксИсключающее</span>:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
установка значения фасета <span class="Term">МаксИсключающее</span> и <span class="Term">МаксВключающее</span> фасета в определении типа не допускается;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
если установлено значение фасета <span class="Term">МинИсключающее</span>, то значение фасета <span class="Term">МаксИсключающее</span> должно быть больше значения
фасета <span class="Term">МинИсключающее</span>
данного типа;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
значение фасета должно быть меньше или равно эффективному
значению фасета базового типа;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
если установлено значение фасета <span class="Term">МаксВключающее</span>, то оно должно быть меньше или
равно эффективному значению базового типа;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
если установлено значение фасета <span class="Term">МинИсключающее</span>, то оно должно быть больше
эффективного значения базового типа;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
если установлено значение фасета <span class="Term">МинВключающее</span>, то оно должно быть больше
эффективного значения базового типа.</p>

<p class="MsoNormal">Правило
для фасета <span class="Term">РазрядовВсего</span>:</p>

<p class="MsoListBullet">&#9679; 
значение фасета должно быть меньше или равно эффективному
значению фасета базового типа.</p>

<p class="MsoNormal">Правила
для фасета <span class="Term">РазрядовДробнойЧасти</span>:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
значение фасета должно быть меньше или равно эффективному
значению фасета <span class="Term">РазрядовВсего</span>;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
значение фасета должно быть меньше или равно эффективному
значению фасета базового типа.</p>

<p class="MsoNormalCxSpFirst"> </p>

<br>

<a name="_ref400448297"></a><a id="TI000001490" class="bookmark" name="issogl1_16.2_работа_с_json"><h2>16.2. Работа с JSON</h2></a>

<a name="_ref399345848"></a><a name="_ref417645050"></a><a name="_ref417645049"></a><a id="TI000001491" class="bookmark" name="issogl2_16.2.1_общая_информация"><h3>16.2.1. Общая информация</h3></a>

<p class="MsoNormal">Формат
JSON является универсальным способом представления при обмене данными (RFC 7159,
<a href="https://tools.ietf.org/html/rfc7159" target="_blank">https://tools.ietf.org/html/rfc7159</a>). Данные в формате JSON представляют собой
(в закодированном виде):</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
<span class="Bold">Объект</span> –
неупорядоченное множество пар <span class="Term">ключ:значение</span>,
заключенный в фигурные скобки (<span class="Term">{}</span>).
Пары <span class="Term">ключ:значение</span>
разделяются запятыми (<span class="Term">,</span>).</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Bold">Массив</span> – множество
значений. Массив заключается в квадратные скобки (<span class="Term">[]</span>). Значения разделяются запятыми (<span class="Term">,</span>).</p>

<p class="MsoListBulletCxSpLast">&#9679; 
<span class="Bold">Значение</span> – может
быть строкой, числом, объектом, массивов или литералом <span class="Term">true</span>, <span class="Term">false</span>, <span class="Term">null</span>.</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
<span class="Bold">Строка</span> – набор
символов, заключенный в двойные кавычки (<span class="Term">&quot;&quot;</span>).</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
<span class="Bold">Число</span> – сериализуется
с разделителем точка (<span class="Term">.</span>).
Точность числа не ограничена.</p>

<p class="MsoNormal">Таким
образом, с помощью вышеперечисленных элементов допускается описание объектов
любой сложности для представления в формате JSON. Например, некоторый код на
встроенном языке, формирует некоторый набор данных (в структуре):</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">Данные <span class="operator">=</span> <span class="keyword">Новый</span> Структура<span class="operator">;</span>
Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;Фамилия&quot;</span><span class="operator">,</span> <span class="string">&quot;Иванов&quot;</span><span class="operator">)</span><span class="operator">;</span>
Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;Имя&quot;</span><span class="operator">,</span> <span class="string">&quot;Иван&quot;</span><span class="operator">)</span><span class="operator">;</span>
Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;Отчество&quot;</span><span class="operator">,</span> <span class="string">&quot;Иванович&quot;</span><span class="operator">)</span><span class="operator">;</span>
Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;ДеньРождения&quot;</span><span class="operator">,</span> ДатаРождения<span class="operator">)</span><span class="operator">;</span>
Телефоны <span class="operator">=</span> <span class="keyword">Новый</span> Массив<span class="operator">;</span>
Телефоны<span class="operator">.</span>Добавить<span class="operator">(</span><span class="string">&quot;+7-987-123-45-67&quot;</span><span class="operator">)</span><span class="operator">;</span>
Телефоны<span class="operator">.</span>Добавить<span class="operator">(</span><span class="string">&quot;+7-986-987-65-43&quot;</span><span class="operator">)</span><span class="operator">;</span>
Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;Телефоны&quot;</span><span class="operator">,</span> Телефоны<span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">Сериализуя
этот объект в JSON, может быть получен следующий документ:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
{
    &quot;Фамилия&quot;: &quot;Иванов&quot;,
    &quot;Имя&quot;: &quot;Иван&quot;,
    &quot;Отчество&quot;: &quot;Иванович&quot;,
    &quot;ДатаРождения&quot;: &quot;2009-02-15T00:00:00Z&quot;,
    &quot;Телефоны&quot;: [
        &quot;+7-987-123-45-67&quot;,
        &quot;+7-986-987-65-43&quot;
    ]
}
</pre>

<p class="MsoNormal">JSON
не стандартизует формат представления даты. В силу этого представление даты в
JSON-документе определяется предпочтениями прикладного разработчика, который
формирует документ, и требованиями системы, которая будет обрабатывать
JSON-документ. Система «1С:Предприятие» поддерживает несколько форматов
представления даты (задается с помощью системного перечисления <span class="Term">ФорматДатыJSON</span>):</p>

<p class="MsoListNumberCxSpFirst">1.  Формат
ISO (значение <span class="Term">ФорматДатыJSON.ISO</span>).
В этом случае дата сериализуется следующим образом: <span class="Interface">&quot;2009-02-15T00:00:00+0400&quot;</span>.</p>

<p class="MsoListNumberCxSpMiddle">2. 
Формат JavaScript (значение <span class="Term">ФорматДатыJSON.JavaScript</span>). В этом случае дата
сериализуется следующим образом: <span class="Interface">&quot;new Date(1234656000000)&quot;</span>.</p>

<p class="MsoListNumberCxSpLast">3. 
Формат Microsoft (значение <span class="Term">ФорматДатыJSON.Microsoft</span>). В этом случае дата
сериализуется следующим образом: <span class="Interface">&quot;\/Date(1234656000000)\/&quot;</span>
или <span class="Interface">&quot;/Date(1234656000000)/&quot;</span> (в зависимости от
режима экранирования символов).</p>

<p class="MsoNormal">Дата
может записываться несколькими вариантами (для примера используется дата 10 мая
2014 13:14:15 в зоне UTC+4):</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
как локальная дата: <span class="Interface">2014-05-10T13:14:15</span>.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
как локальная дата с указанием смещения: <span class="Interface">2014-05-10T13:14:15+04:00</span>.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
как дата в UTC: <span class="Interface">2014-05-10T09:14:15Z</span>.</p>

<p class="MsoNormalCxSpFirst">Управлять
этим можно с помощью системного перечисления <span class="Term">ВариантЗаписиДатыJSON</span>. Дату в варианте UTC
можно записать в любом формате (ISO, JavaScript и Microsoft), остальные
варианты представления даты возможны только в том случае, если сериализация выполняется
в формате ISO.</p>

<p class="MsoNormalCxSpMiddle">При
записи JSON-документа предоставляются возможности по управлению формируемыми
данными: настраивать перенос строк, формат сериализации даты, обработка символа
&quot;<span class="Interface">/</span>&quot; и т. д. Эти настройки можно выполнять
с помощью объектов <span class="Term">НастройкиСериализацииJSON</span>
и <span class="Term">ПараметрыЗаписиJSON</span>.</p>

<p class="MsoNormalCxSpLast">Работа
с данными в формате JSON может выполняться в нескольких техниках:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
Объектная техника – позволяет формировать
простые и небольшие JSON-документы для обмена с внешними приложениями или
веб-сервисами. Структура JSON-документа автоматически формируется системой
«1С:Предприятие» во время записи документа. Более подробно описание данной
техники см. <a href="#_ref399340838">здесь</a>. Специальным вариантом такой техники является возможность
сериализации в формате JSON для XDTO-объектов системы «1С:Предприятие». Более
подробное описание работы с XDTO-объектами см. <a href="#_ref417645070">здесь</a>.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
Потоковая техника – позволяет работать с
данными большого объема без загрузки их в память приложения. Навигация по JSON-документу
полностью ложится на прикладного разработчика (как при записи, так и при чтении
документа). Более подробно описание данной техники см. <a href="#_ref400380585">здесь</a>.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
Совмещенная техника – позволяет сочетать
гибкость потоковой техники и простоту объектной техники. Более подробно
описание данной техники см. <a href="#_ref400445950">здесь</a>.</p>

<a name="_ref399340838"></a><a name="_ref417985150"></a><a id="TI000001492" class="bookmark" name="issogl2_16.2.2_объектная_техника_работы"><h3>16.2.2. Объектная техника работы</h3></a>

<a name="_ref399340984"></a><a id="TI000001493" class="bookmark" name="issogl3_16.2.2.1_общая_информация"><h4>16.2.2.1. Общая информация</h4></a>

<p class="MsoNormal">Система «1С:Предприятие» поддерживает
сериализацию следующих данных в формат JSON:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
<span class="Term">Строка</span> – сериализуется в строку;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Число</span> – сериализуется в число;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Булево</span> – сериализуется в литералы <span class="Term">true</span>
и <span class="Term">false</span>;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Неопределено</span> – сериализуется в <span class="Term">null</span></p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Массив</span>, <span class="Term">ФиксированныйМассив</span> –
сериализуется в массив JSON в том случае, если любой
элемент массива может быть сериализован в JSON.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
<span class="Term">Структура</span>, <span class="Term">ФиксированнаяСтруктура</span> –
сериализуется в объект JSON:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
Ключ – ключ элемента структуры.</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
Значение – значение элемента структуры в том случае, если значение может быть сериализовано в JSON.</p>

<p class="MsoListBullet">&#9679; 
<span class="Term">Соответствие</span>, <span class="Term">ФиксированноеСоответствие</span> –
сериализуется в объект JSON:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
Ключ – ключ элемента соответствия. Ключ
может быть только значением типа <span class="Term">Строка</span>,
в противном случае будет генерироваться исключение.</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
Значение – значение элемента соответствия в
том случае, если значение может быть сериализовано в JSON.</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
<span class="Term">Дата</span> – формат сериализации определяется
настройками.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
Если выполняется попытка сериализации типа,
отсутствующего в данном списке – будет вызвано исключение.</p>

<p class="MsoNormalCxSpFirst">При работе с объектной техникой, имеется
возможность читать (и писать) данные в соответствие или структуру. Основное отличие
между этими объектами состоит в том, что ключ элемента структуры подчиняется
правилам формирования переменной на встроенном языке, а ключ элемента
соответствия может быть любым. С учетом того, чтоб JSON не накладывает
ограничений на значение ключа, не все JSON-документы можно прочитать в
структуру. Еще одним различием между структурой и соответствием является то,
что к элементам структуры можно обращаться «через точку», а к элементам соответствия
такой доступ не предоставляется. В связи с этим, может оказаться удобным
получать данные в виде структуры, если ключи из JSON-документа соответствуют
требованиям к ключам структур системы «1С:Предприятие».</p>

<p class="MsoNormalCxSpLast">Объектная техника предполагает достаточно
простую работу с данными, однако платой за это является большой расход памяти, т. к.
весь JSON-документ обрабатывается целиком в оперативной памяти.</p>

<a name="_ref445483760"></a><a name="_ref445483759"></a><a id="TI000001494" class="bookmark" name="issogl3_16.2.2.2_запись"><h4>16.2.2.2. Запись</h4></a>

<p class="MsoNormal">Для того чтобы выполнить запись объекта в
формате JSON, необходимо использовать (в простейшем случае) следующие объекты:</p>

<p class="MsoListNumberCxSpFirst">1. 
Собственно записываемый объект, например типа <span class="Term">Структура</span>.</p>

<p class="MsoListNumberCxSpMiddle">2.  Объект,
обеспечивающий низкоуровневую запись данных в формате JSON – <span class="Term">ЗаписьJSON</span>.</p>

<p class="MsoListNumberCxSpLast">3.  Объект
настроек сериализации <span class="Term">НастройкиСериализацииJSON</span>.</p>

<p class="MsoNormal">Метод глобального контекста <span class="Term">ЗаписатьJSON()</span>
оперирует вышеперечисленными объектами. Рассмотрим пример, в котором
потребуется записать структуру, которая состоит из трех элементов разного типа
(но типы являются примитивными):</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">Запись <span class="operator">=</span> <span class="keyword">Новый</span> ЗаписьJSON<span class="operator">;</span>
Запись<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;c:\temp\simpleWrite.json&quot;</span><span class="operator">)</span><span class="operator">;</span>
Данные <span class="operator">=</span> <span class="keyword">Новый</span> Структура<span class="operator">;</span>
Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;ДлинаЗаписи&quot;</span><span class="operator">,</span> <span class="number">20</span><span class="operator">)</span><span class="operator">;</span>
Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;КлючЗаписи&quot;</span><span class="operator">,</span> <span class="string">&quot;abcdefgh&quot;</span><span class="operator">)</span><span class="operator">;</span>
Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;ДатаИзменения&quot;</span><span class="operator">,</span> ТекущаяДата<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
ЗаписатьJSON<span class="operator">(</span>Запись<span class="operator">,</span> Данные<span class="operator">,</span> <span class="keyword">Новый</span> НастройкиСериализацииJSON<span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">В результате работы
данный пример сформирует следующий JSON-документ:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
{
&quot;ДлинаЗаписи&quot;: 20,
&quot;КлючЗаписи&quot;: &quot;abcdefgh&quot;,
&quot;ДатаИзменения&quot;: &quot;2014-09-24T17:32:11&quot;
}
</pre>

<p class="MsoNormal">Если в сериализуемых данных участвуют
значения типа <span class="Term">Дата</span>, то может потребоваться управлять форматом
сериализации. Для этого необходимо установить параметры объекта <span class="Term">НастройкиСериализацииJSON</span>.
В следующем примере дата будет сериализоваться в формате <span class="Term">JavaScript</span>:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">НастройкиСериализации <span class="operator">=</span> <span class="keyword">Новый</span> НастройкиСериализацииJSON<span class="operator">;</span>
НастройкиСериализации<span class="operator">.</span>ФорматСериализацииДат <span class="operator">=</span> ФорматДатыJSON<span class="operator">.</span>JavaScript<span class="operator">;</span>
НастройкиСериализации<span class="operator">.</span>ВариантЗаписиДаты <span class="operator">=</span> ВариантЗаписиДатыJSON<span class="operator">.</span>УниверсальнаяДата<span class="operator">;</span>
Запись <span class="operator">=</span> <span class="keyword">Новый</span> ЗаписьJSON<span class="operator">;</span>
Запись<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;c:\temp\simpleWrite.json&quot;</span><span class="operator">)</span><span class="operator">;</span>
Данные <span class="operator">=</span> <span class="keyword">Новый</span> Структура<span class="operator">;</span>
Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;ДлинаЗаписи&quot;</span><span class="operator">,</span> <span class="number">20</span><span class="operator">)</span><span class="operator">;</span>
Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;КлючЗаписи&quot;</span><span class="operator">,</span> <span class="string">&quot;abcdefgh&quot;</span><span class="operator">)</span><span class="operator">;</span>
Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;ДатаИзменения&quot;</span><span class="operator">,</span> ТекущаяДата<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
ЗаписатьJSON<span class="operator">(</span>Запись<span class="operator">,</span> Данные<span class="operator">,</span> НастройкиСериализации<span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">В результате работы данный пример сформирует
следующий JSON-документ:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
{
&quot;ДлинаЗаписи&quot;: 20,
&quot;КлючЗаписи&quot;: &quot;abcdefgh&quot;,
&quot;ДатаИзменения&quot;: &quot;new Date(1411565832000)&quot;
}
</pre>

<p class="MsoNormal">Если несколько расширить набор записываемых
данных, например, добавить к ним значение типа <span class="Term">УникальныйИдентификатор</span>,
то запись не будет выполнена. В результате исполнения кода:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">Запись <span class="operator">=</span> <span class="keyword">Новый</span> ЗаписьJSON<span class="operator">;</span>
Запись<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;c:\temp\simpleWrite.json&quot;</span><span class="operator">)</span><span class="operator">;</span>
Данные <span class="operator">=</span> <span class="keyword">Новый</span> Структура<span class="operator">;</span>
Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;ДлинаЗаписи&quot;</span><span class="operator">,</span> <span class="number">20</span><span class="operator">)</span><span class="operator">;</span>
Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;КлючЗаписи&quot;</span><span class="operator">,</span> <span class="string">&quot;abcdefgh&quot;</span><span class="operator">)</span><span class="operator">;</span>
Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;ДатаИзменения&quot;</span><span class="operator">,</span> ТекущаяДата<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;UID&quot;</span><span class="operator">,</span> <span class="keyword">Новый</span> УникальныйИдентификатор<span class="operator">)</span><span class="operator">;</span>
ЗаписатьJSON<span class="operator">(</span>Запись<span class="operator">,</span> Данные<span class="operator">,</span> <span class="keyword">Новый</span> НастройкиСериализацииJSON<span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">Будет вызвано исключение:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
Ошибка при вызове метода контекста (ЗаписатьJSON)
ЗаписатьJSON(Запись, Данные, Новый НастройкиСериализацииJSON);
по причине:
Передано значение недопустимого типа
</pre>

<p class="MsoNormalCxSpFirst">Причиной такого поведения является то, что
тип <span class="Term">УникальныйИдентификатор</span> не входит в состав JSON-сериализуемых
типов данных системы «1С:Предприятие». Однако система предоставляет возможность
«обойти» это ограничение: необходимо передать в функцию
<span class="Term">ЗаписатьJSON()</span>
имя функции обратного вызова, которая будет заниматься JSON-сериализацией
неподдерживаемых объектов. Эта функция будет называться <span class="Bold">функцией
преобразования</span>. При этом формат такой сериализации будет разрабатывать
непосредственно сам прикладной разработчик. Надо понимать, что такая
сериализация не будет универсальной, т. к. принимающая сторона, не
обладающая знаниями о формате сериализации, не сможет прочитать переданные
данные. Другими словами, формат сериализации необходимо разрабатывать совместно
всеми сторонами обмена такого рода данными.</p>

<p class="MsoNormalCxSpLast">С учетом вышесказанного, более сложный
вариант обмена теперь происходит следующим образом:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
Вызывается функция сериализации объекта в формат
JSON (<span class="Term">ЗаписатьJSON()</span>).</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
Система «1С:Предприятие» для каждого элемента
структуры, тип значения которого не сериализуется в формат JSON, будет
вызываться функция преобразования.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
Функция преобразования анализирует переданный
объект и принимает решение – отказаться от его записи или вернуть
платформе значение, которое может быть сериализовано в JSON.</p>

<p class="MsoNormal">Доработанный код записи будет выглядеть
следующим образом:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev"><span class="preprocessor">&amp;НаСервере</span>
<span class="keyword">Процедура</span> ЗаписьНаСервере<span class="operator">(</span><span class="operator">)</span>
    Запись <span class="operator">=</span> <span class="keyword">Новый</span> ЗаписьJSON<span class="operator">;</span>
    Запись<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;c:\temp\compositeWrite.json&quot;</span><span class="operator">)</span><span class="operator">;</span>
 Данные <span class="operator">=</span> <span class="keyword">Новый</span> Структура<span class="operator">;</span>
    Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;ДлинаЗаписи&quot;</span><span class="operator">,</span> <span class="number">20</span><span class="operator">)</span><span class="operator">;</span>
    Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;КлючЗаписи&quot;</span><span class="operator">,</span> <span class="string">&quot;abcdefgh&quot;</span><span class="operator">)</span><span class="operator">;</span>
    Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;ДатаИзменения&quot;</span><span class="operator">,</span> ТекущаяДата<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
    Данные<span class="operator">.</span>Вставить<span class="operator">(</span><span class="string">&quot;UID&quot;</span><span class="operator">,</span> <span class="keyword">Новый</span> УникальныйИдентификатор<span class="operator">)</span><span class="operator">;</span>
    ЗаписатьJSON<span class="operator">(</span>Запись<span class="operator">,</span> Данные<span class="operator">,</span> <span class="keyword">Новый</span> НастройкиСериализацииJSON<span class="operator">,</span> <span class="string">&quot;ФункцияПреобразованияЗаписи&quot;</span><span class="operator">,</span> ЭтотОбъект<span class="operator">)</span><span class="operator">;</span>
    Запись<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">КонецПроцедуры</span>
<span class="preprocessor">&amp;НаСервере</span>
<span class="keyword">Функция</span> ФункцияПреобразованияЗаписи<span class="operator">(</span>Свойство<span class="operator">,</span> Значение<span class="operator">,</span> ДополнительныеПараметры<span class="operator">,</span> Отказ<span class="operator">)</span> <span class="keyword">Экспорт</span>
    <span class="keyword">Если</span> ТипЗнч<span class="operator">(</span>Значение<span class="operator">)</span> <span class="operator">=</span> Тип<span class="operator">(</span><span class="string">&quot;УникальныйИдентификатор&quot;</span><span class="operator">)</span> <span class="keyword">Тогда</span>
        <span class="keyword">Возврат</span> Строка<span class="operator">(</span>Значение<span class="operator">)</span><span class="operator">;</span>
    <span class="keyword">КонецЕсли</span><span class="operator">;</span>
    Отказ <span class="operator">=</span> <span class="keyword">Истина</span><span class="operator">;</span>
<span class="keyword">КонецФункции</span></pre>

<p class="MsoNormalCxSpFirst">Следует обратить внимание, что функция
преобразования должна быть объявлена с указанием ключевого слова <span class="Term">Экспорт</span>.
Также следует помнить, что функция преобразования (в модуле управляемой формы)
может быть описана только в «контекстной» части модуля, т. е. с
использованием директивы компиляции <span class="Term">&amp;НаКлиенте</span>
или <span class="Term">&amp;НаСервере</span>.</p>

<p class="MsoNormalCxSpLast">В результате работы приведенного примера
будет сформирован следующий JSON-документ:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
{
&quot;ДлинаЗаписи&quot;: 20,
&quot;КлючЗаписи&quot;: &quot;abcdefgh&quot;,
&quot;ДатаИзменения&quot;: &quot;2014-09-24T18:09:13&quot;,
&quot;UID&quot;: &quot;5a80e5dc-252b-416f-b487-d9ddcebc523e&quot;
}
</pre>

<p class="MsoNormal">При создании функции преобразования следует
помнить о следующих особенностях:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
Функция преобразования вызывается для значений
всех типов, которые не поддерживают сериализацию в JSON (см. <a href="#_ref399345848">здесь</a>).</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
Если функция преобразования вернет значение,
которое не может быть сериализовано в JSON – будет вызвано исключение.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
Если переданное значение является структурой, то
вызов функции преобразования для элементов этой структуры будет вызваться до
того, как в поток будет записано имя свойства этого элемента. В результате
функция преобразования может отказаться от записи значения и структура
формируемого JSON-документа не будет нарушена.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
Имя свойства будет передано в функцию
преобразования только для элементов структур и соответствий.</p>

<a id="TI000001495" class="bookmark" name="issogl3_16.2.2.3_чтение"><h4>16.2.2.3. Чтение</h4></a>

<a name="_ref445483775"></a><a id="TI000001583" class="bookmark" name="issogl4_16.2.2.3.1_общая_схема"><h5>16.2.2.3.1. Общая схема</h5></a>

<p class="MsoNormal">Чтение данных в объектной технике выглядит
аналогично записи. Рассмотрим пример чтения файлов, которые формировались во
время рассмотрения объектной записи (предыдущий раздел).</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">Чтение <span class="operator">=</span> <span class="keyword">Новый</span> ЧтениеJSON<span class="operator">;</span>
Чтение<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;c:\temp\simpleWrite.json&quot;</span><span class="operator">)</span><span class="operator">;</span>
Данные <span class="operator">=</span> ПрочитатьJSON<span class="operator">(</span>Чтение<span class="operator">,</span> <span class="keyword">Ложь</span><span class="operator">,</span> <span class="string">&quot;ДатаИзменения&quot;</span><span class="operator">,</span> ФорматДатыJSON<span class="operator">.</span>JavaScript<span class="operator">)</span><span class="operator">;</span>
Чтение<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">Документ имеет следующее содержание (с
точностью до значения даты):</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
{
&quot;ДлинаЗаписи&quot;: 20,
&quot;КлючЗаписи&quot;: &quot;abcdefgh&quot;,
&quot;ДатаИзменения&quot;: &quot;new Date(1411565832000)&quot;
}
</pre>

<p class="MsoNormal">При чтении JSON-документа в переменную <span class="Term">Данные</span>
будет сформирована структура вида:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
Ключ = ДлинаЗаписи, значение = 20
Ключ = КлючЗаписи, значение = abcdefgh
Ключ = ДатаИзменения, значение = &lt;значение даты и времени&gt;
</pre>

<p class="MsoNormal">Такой вариант чтения хорошо подходит в том
случае, если читаемые данные могут быть преобразованы в структуру или соответствие
и все читаемые данные могут быть однозначно десериализованы без потери
информации о типе. Если читаемые данные обладают сложной структурой или требуют
выполнения дополнительных преобразований при чтении, то можно пойти двумя
путями:</p>

<p class="MsoListNumberCxSpFirst">1. 
Получить соответствие (или структуру), в которое
будет полностью загружен JSON-документ, и потом завершить преобразование с
помощью обхода получившегося объекта.</p>

<p class="MsoListNumberCxSpLast">2.  Заниматься
необходимым преобразованием непосредственно во время загрузки данных. Для этого
необходимо передать в функцию <span class="Term">ПрочитатьJSON()</span>
имя функции обратного вызова, которая будет заниматься десериализацией JSON-данных
в нужные объекты системы «1С:Предприятие». Эта функция будет называться <span class="Bold">функцией восстановления</span>.</p>

<p class="MsoNormal">В обоих случаях прикладной разработчик
должен знать, какие данные и в каком виде находятся JSON-документе. Далее будут
подробно рассмотрены оба варианта загрузки данных. В качестве макетной задачи
будет рассматриваться получение погоды в г. Москва с помощью некоторого
интернет-сервиса. В качестве ответа интернет-сервис возвращает JSON-документ следующего
содержания:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
{
    &quot;id&quot;:524901,&quot;name&quot;:&quot;Moscow&quot;,&quot;dt&quot;:1411464940000,
    &quot;coord&quot;: { &quot;lon&quot;:37.62,&quot;lat&quot;:55.75 },
    &quot;sys&quot;: { &quot;country&quot;:&quot;RU&quot;,&quot;sunrise&quot;:1411442400000,&quot;sunset&quot;:1411485660000 },
    &quot;weather&quot;: [
        { &quot;main&quot;:&quot;Clouds&quot;,&quot;description&quot;:&quot;пасмурно&quot; }
    ],
    &quot;main&quot;: { &quot;temp&quot;:282.93,&quot;pressure&quot;:1014,&quot;humidity&quot;:93 },
    &quot;wind&quot;: { &quot;speed&quot;:4,&quot;deg&quot;:350 },
    &quot;clouds&quot;: { &quot;all&quot;:90 }
}
</pre>

<p class="MsoNormal">Кратко рассмотрим описание формата:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
id – идентификатор города;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">name</span> – имя города;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">dt</span> – дата и время получения погоды, в формате Unix, GMT;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
<span class="Term">coord</span> – местоположение города:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
<span class="Term">lon</span> – долгота;</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
<span class="Term">lan</span> – широта.</p>

<p class="MsoListBullet">&#9679; 
<span class="Term">sys</span> – дополнительная информация:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
<span class="Term">country</span> – страна расположения города;</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
sunrise – время восхода Солнца в формате Unix,
GMT;</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
<span class="Term">sunset</span> – время заката Солнца, в формате Unix,
GMT.</p>

<p class="MsoListBullet">&#9679; 
<span class="Term">weather</span> – дополнительная информация о
погоде:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
<span class="Term">main</span> – общая характеристика погоды;</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
<span class="Term">description</span> – описание погоды.</p>

<p class="MsoListBullet">&#9679; 
<span class="Term">main</span> – собственно описание погоды:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
<span class="Term">temp</span> – температура, в градусах Кельвина.
Для получения градусов Цельсия необходимо вычесть 273.15;</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
<span class="Term">pressure</span> – давление в гектопаскалях. Для
перевода в миллиметры ртутного столба, надо значение давления умножить на 0,75.</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
<span class="Term">humidity</span> – влажность в %.</p>

<p class="MsoListBullet">&#9679; 
<span class="Term">wind</span> – параметры ветра:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
<span class="Term">speed</span> – скорость в милях в час. Для
перевода в километры в час необходимо умножить на 1,61.</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
<span class="Term">deg</span> – направление ветра, в градусах.</p>

<p class="MsoListBullet">&#9679; 
<span class="Term">clouds</span> – информация об осадках:</p>

<p class="MsoListBullet2">&#9679; 
<span class="Term">all</span> – вероятность возникновения осадков,
в %.</p>

<p class="MsoNormalCxSpFirst">В результате загрузки этих данных должна
получиться структура, где все времена представлены стандартным типом <span class="Term">Дата</span>,
температура – в градусах Цельсия, скорость – в километрах в час, а
давление – в миллиметрах ртутного столба.</p>

<p class="MsoNormalCxSpLast">Рассмотрим загрузку данной информации обоими
способами. Данные записаны в файле <span class="Interface">c:\temp\weather.json</span>.</p>

<a id="TI000001496" class="bookmark" name="issogl4_16.2.2.3.2_чтение_с_постобработкой"><h5>16.2.2.3.2. Чтение с постобработкой</h5></a>

<p class="MsoNormal">Собственно процесс чтения выглядит просто:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
Чтение = Новый ЧтениеJSON;
Чтение.ОткрытьФайл(&quot;c:\temp\weather.json&quot;);
Данные = ПрочитатьJSON(Чтение, Ложь);
Чтение.Закрыть();
</pre>

<p class="Regularbeforepicture">В результате в переменной <span class="Term">Данные</span>
будет следующая информация:</p>

<p class="Picture"><IMG src="_img/img00456.gif?_=1496848987" WIDTH="510" ALT HEIGHT="614"></p>

<p class="MsoCaption">Рис. 448. Результат загрузки</p>

<p class="MsoNormal">Без учета необходимости конвертации все
выглядит предсказуемо. Однако дата и время автоматически не преобразовались.
Можно попробовать указать системе на то, что поле <span class="Term">dt</span>
(например) является полем, где находится дата и время:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
Чтение = Новый ЧтениеJSON;
Чтение.ОткрытьФайл(&quot;c:\temp\weather.json&quot;);
Данные = ПрочитатьJSON(Чтение, Ложь, &quot;dt&quot;, ФорматДатыJSON.JavaScript);
Чтение.Закрыть();
</pre>

<p class="MsoNormal">В результате получим сообщение об ошибке
следующего вида:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
Ошибка при вызове метода контекста (ПрочитатьJSON)
    Данные = ПрочитатьJSON(Чтение, Ложь, &quot;dt&quot;, ФорматДатыJSON.JavaScript);
по причине:
Представление даты имеет неверный формат
</pre>

<p class="MsoNormal">Ошибка произошла потому, что система не
понимает формат даты и времени, выраженной простым числом. Программный интерфейс
работы с JSON предлагает функцию, помогающую выполнить конвертацию полей типа <span class="Term">Дата</span> –
<span class="Term">ПрочитатьДатуJSON()</span>. Для использования этой
функции необходимо привести десериализованную строку к формату, принятому,
например, в JavaScript. В рассматриваемом примере получится следующий
программный текст:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">Данные<span class="operator">.</span>dt <span class="operator">=</span> ПрочитатьДатуJSON<span class="operator">(</span><span class="string">&quot;new Date(&quot;</span><span class="operator">+</span>Формат<span class="operator">(</span>Данные<span class="operator">.</span>dt<span class="operator">,</span> <span class="string">&quot;ЧГ=&quot;</span><span class="operator">)</span><span class="operator">+</span><span class="string">&quot;)&quot;</span><span class="operator">,</span> ФорматДатыJSON<span class="operator">.</span>JavaScript<span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">В результате значение свойства <span class="Term">Данные.dt</span>
станет равно значению <span class="Term">23.09.2014 13:35:40</span>
(типа <span class="Term">Дата</span>). Остальная конвертация выполняется
аналогичным образом.</p>

<a id="TI000001497" class="bookmark" name="issogl4_16.2.2.3.3_чтение_с_функцией_восстановления"><h5>16.2.2.3.3. Чтение с функцией восстановления</h5></a>

<p class="MsoNormalCxSpFirst">Вариант постобработкой выглядит не очень
хорошо, если чтение JSON-документа предполагается выполнять в разных местах
прикладного решения. В этом случае может возникнуть ситуация, когда код
преобразования будет расположен в нескольких местах прикладного решения.</p>

<p class="MsoNormalCxSpLast">Хорошей заменой постобработки, в этом
случае, является использование функции восстановления. Для применения функции
восстановления необходимо описать саму функцию и несколько изменить само чтение
документа:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev"><span class="preprocessor">&amp;НаСервере</span>
<span class="keyword">Функция</span> ФункцияВосстановленияЧтения<span class="operator">(</span>Свойство<span class="operator">,</span> Значение<span class="operator">,</span> ДополнительныеПараметры<span class="operator">)</span> <span class="keyword">Экспорт</span>
    <span class="keyword">Если</span> Свойство <span class="operator">=</span> <span class="string">&quot;dt&quot;</span> <span class="keyword">ИЛИ</span> Свойство <span class="operator">=</span> <span class="string">&quot;sunrise&quot;</span> <span class="keyword">ИЛИ</span> Свойство <span class="operator">=</span> <span class="string">&quot;sunset&quot;</span> <span class="keyword">Тогда</span>
        <span class="keyword">Возврат</span> ПрочитатьДатуJSON<span class="operator">(</span><span class="string">&quot;new Date(&quot;</span><span class="operator">+</span>Формат<span class="operator">(</span>Значение<span class="operator">,</span> <span class="string">&quot;ЧГ=&quot;</span><span class="operator">)</span><span class="operator">+</span><span class="string">&quot;)&quot;</span><span class="operator">,</span> ФорматДатыJSON<span class="operator">.</span>JavaScript<span class="operator">)</span><span class="operator">;</span>
    <span class="keyword">КонецЕсли</span><span class="operator">;</span>
    <span class="keyword">Если</span> Свойство <span class="operator">=</span> <span class="string">&quot;pressure&quot;</span> <span class="keyword">Тогда</span>
        <span class="keyword">Возврат</span> Значение<span class="operator">*</span><span class="number">0</span><span class="number">.</span><span class="number">75</span><span class="operator">;</span>
    <span class="keyword">КонецЕсли</span><span class="operator">;</span>
    <span class="keyword">Если</span> Свойство <span class="operator">=</span> <span class="string">&quot;temp&quot;</span> <span class="keyword">Тогда</span>
        <span class="keyword">Возврат</span> Значение<span class="operator">-</span><span class="number">273</span><span class="number">.</span><span class="number">15</span><span class="operator">;</span>
    <span class="keyword">КонецЕсли</span><span class="operator">;</span>
    <span class="keyword">Если</span> Свойство <span class="operator">=</span> <span class="string">&quot;speed&quot;</span> <span class="keyword">Тогда</span>
        <span class="keyword">Возврат</span> Значение<span class="operator">*</span><span class="number">1</span><span class="number">.</span><span class="number">61</span><span class="operator">;</span>
    <span class="keyword">КонецЕсли</span><span class="operator">;</span>
<span class="keyword">КонецФункции</span>
<span class="preprocessor">&amp;НаСервере</span>
<span class="keyword">Процедура</span> ЧтениеНаСервере<span class="operator">(</span><span class="operator">)</span>
    Чтение <span class="operator">=</span> <span class="keyword">Новый</span> ЧтениеJSON<span class="operator">;</span>
    Чтение<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;c:\temp\weather.json&quot;</span><span class="operator">)</span><span class="operator">;</span>
    Данные <span class="operator">=</span> ПрочитатьJSON<span class="operator">(</span>Чтение<span class="operator">,</span> <span class="keyword">Ложь</span><span class="operator">,</span> <span class="operator">,</span> <span class="operator">,</span> <span class="string">&quot;ФункцияВосстановленияЧтения&quot;</span><span class="operator">,</span> ЭтотОбъект<span class="operator">)</span><span class="operator">;</span>
    Чтение<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">КонецПроцедуры</span></pre>

<p class="MsoNormal">В вышеуказанном примере присутствует
особенность – функция восстановления будет вызвана для всех свойств,
которые будут обнаружены в JSON-документе. Это не всегда удобно и, кроме того,
существенно снижает производительность чтения JSON-документа (за счет вызова
функции восстановления). Например, при чтении метеорологических данных нам
необходимо выполнять особое преобразование только для свойств, в которых
содержится дата и время, а остальные свойства мы конвертировать не собираемся.
Чтобы не анализировать в функции восстановления имя реквизита (как в
вышеприведенном примере), можно поступить другим способом: явным образом
передать в функцию чтения JSON-документа список реквизитов, которые содержат
дату и время, а функцию восстановления написать исходя из того, что эта функция
будет вызвана только для необходимых свойств. В результате получится следующий
код:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev"><span class="preprocessor">&amp;НаСервере</span>
<span class="keyword">Процедура</span> ЧтениеНаСервере<span class="operator">(</span><span class="operator">)</span>
    Чтение <span class="operator">=</span> <span class="keyword">Новый</span> ЧтениеJSON<span class="operator">;</span>
    Чтение<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;c:\temp\weather.json&quot;</span><span class="operator">)</span><span class="operator">;</span>
    Реквизиты <span class="operator">=</span> <span class="keyword">Новый</span> Массив<span class="operator">;</span>
    Реквизиты<span class="operator">.</span>Добавить<span class="operator">(</span><span class="string">&quot;dt&quot;</span><span class="operator">)</span><span class="operator">;</span>
    Реквизиты<span class="operator">.</span>Добавить<span class="operator">(</span><span class="string">&quot;sunrise&quot;</span><span class="operator">)</span><span class="operator">;</span>
    Реквизиты<span class="operator">.</span>Добавить<span class="operator">(</span><span class="string">&quot;sunset&quot;</span><span class="operator">)</span><span class="operator">;</span>
    Данные <span class="operator">=</span> ПрочитатьJSON<span class="operator">(</span>Чтение<span class="operator">,</span> <span class="keyword">Ложь</span><span class="operator">,</span> <span class="operator">,</span> <span class="operator">,</span> <span class="string">&quot;ФункцияВосстановленияЧтения&quot;</span><span class="operator">,</span> ЭтотОбъект<span class="operator">,</span> <span class="operator">,</span> Реквизиты<span class="operator">)</span><span class="operator">;</span>
    Чтение<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">КонецПроцедуры</span>
<span class="preprocessor">&amp;НаСервере</span>
<span class="keyword">Функция</span> ФункцияВосстановленияЧтения<span class="operator">(</span>Свойство<span class="operator">,</span> Значение<span class="operator">,</span> ДополнительныеПараметры<span class="operator">)</span> <span class="keyword">Экспорт</span>
    <span class="keyword">Возврат</span> ПрочитатьДатуJSON<span class="operator">(</span><span class="string">&quot;new Date(&quot;</span><span class="operator">+</span>Формат<span class="operator">(</span>Значение<span class="operator">,</span> <span class="string">&quot;ЧГ=&quot;</span><span class="operator">)</span><span class="operator">+</span><span class="string">&quot;)&quot;</span><span class="operator">,</span> ФорматДатыJSON<span class="operator">.</span>JavaScript<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">КонецФункции</span></pre>

<p class="MsoNormal">Следует обратить внимание, что функция
восстановления должна быть объявлена с указанием ключевого слова <span class="Term">Экспорт</span>.
Также следует помнить, что функция восстановления (в модуле управляемой формы)
может быть описана только в «контекстной» части модуля, т. е. с
использованием директивы компиляции <span class="Term">&amp;НаКлиенте</span>
или <span class="Term">&amp;НаСервере</span>. При разработке функции
восстановления необходимо принимать во внимание тот факт, что свойства
документа считываются не в том порядке, как они представлены в файле.</p>

<p class="Regularbeforetable">Рассмотрим последовательность, в которой
свойства JSON-документа попадают в функцию восстановления. Для этого разместим
в таблице каждое свойство файла и то, в каком порядке будет прочитано свойство:</p>

<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <thead>
  <tr>
   <td>
   <p class="MsoNormalCxSpFirst">Данные JSON-документа</p>
   </td>
   
   <td>
   <p class="MsoNormalCxSpMiddle">Последовательность вызова</p>
   <p class="MsoNormalCxSpMiddle">функции восстановления</p>
   </td>
   
  </tr>
 </thead>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">{ &quot;id&quot;:524901,</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">1</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">&quot;name&quot;:&quot;Moscow&quot;,</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">2</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">&quot;dt&quot;:1411464940000,</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">3</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">&quot;coord&quot;:</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">6</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">{ &quot;lon&quot;:37.62,</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">4</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">&quot;lat&quot;:55.75 },</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">5</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">&quot;sys&quot;:</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">9</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">{ &quot;country&quot;:&quot;RU&quot;,</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">6</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">&quot;sunrise&quot;:1411442400000,</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">7</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">&quot;sunset&quot;:1411485660000 },</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">8</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">&quot;weather&quot;:</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">12</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">[</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">11</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">{ &quot;main&quot;:&quot;Clouds&quot;,</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">9</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">&quot;description&quot;:&quot;пасмурно&quot;
  }</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">10</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">],</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"> </p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">&quot;main&quot;:</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">16</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">{ &quot;temp&quot;:282.93,</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">13</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">&quot;pressure&quot;:1014,</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">14</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">&quot;humidity&quot;:93 },</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">15</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">&quot;wind&quot;:</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">19</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">{ &quot;speed&quot;:4,</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">17</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">&quot;deg&quot;:350 },</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">18</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">&quot;clouds&quot;:</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">20</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface">{ &quot;all&quot;:90 }</span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">21</p>
  </td>
  
 </tr>
 <tr>
  <td valign="top">
  <p class="MsoNormalCxSpMiddle"><span class="Interface"> </span></p>
  </td>
  
  <td valign="top">
  <p class="MsoNormalCxSpMiddle">22</p>
  </td>
  
 </tr>
</table>

<p class="MsoNormalCxSpLast">В общем случае, можно сформулировать
следующее правило обхода: первым будет прочитано свойство, которому не
подчинено ни одно другое свойство. Например, свойству <span class="Term">id</span>
не подчинено никакое свойство, и оно считывается первым. Однако свойству <span class="Term">coord</span>
подчинено свойства <span class="Term">lon</span> и <span class="Term">lat</span>,
поэтому вначале будут считаны эти свойства, а лишь затем – свойство <span class="Term">coord</span>,
которое в качестве значения получит структуру (или соответствие) из подчиненных
свойств документа.</p>

<a name="_ref400380585"></a><a name="_ref417645070"></a><a id="TI000001578" class="bookmark" name="issogl2_16.2.3_работа_с_xdto-объектами"><h3>16.2.3. Работа с XDTO-объектами</h3></a>

<a id="TI000001579" class="bookmark" name="issogl3_16.2.3.1_общая_информация"><h4>16.2.3.1. Общая информация</h4></a>

<p class="MsoNormalCxSpFirst">Работа
с XDTO-объектами, в основном, ориентирована на обмен информации между
системами, написанными на платформе «1С:Предприятие». Однако сам механизм не
накладывает никаких ограничений на его использование для обмена с другими системами.</p>

<p class="MsoNormalCxSpMiddle">JSON-сериализация
XDTO-объекта выполняется сразу в JSON-документ, без формирования в памяти
полной структуры сериализуемых объектов. Также следует учитывать, что
JSON-сериализация «эмулирует» XML-сериализацию, в силу чего получающийся
JSON-документ внешне выглядит очень похоже на соответствующий XML-документ.</p>

<p class="MsoNormalCxSpLast">В
JSON-документ могут быть помещены любые объекты системы «1С:Предприятие», для
которых указано, что они могут быть сериализованы в XDTO (см. <A href="/db/content/v8310doc/src/руководство разработчика/глава 4. встроенный язык.htm?_=1496848987#_ref417645360">здесь</a>). При попытке выполнить сериализацию значения
неподдерживаемого типа будет вызвано исключение.</p>

<a name="_ref417988598"></a><a id="TI000001580" class="bookmark" name="issogl3_16.2.3.2_запись"><h4>16.2.3.2. Запись</h4></a>

<p class="MsoNormal">Для
того чтобы выполнить запись XDTO-объекта в формате JSON, необходимо
использовать (в простейшем случае) следующие объекты:</p>

<p class="MsoListNumberCxSpFirst">1.  Собственно
записываемый объект, поддерживающий преобразование в/из XDTO, например, элемент
справочника.</p>

<p class="MsoListNumberCxSpMiddle">2.  Сериализатор
XDTO-объектов – <span class="Term">СериализаторXDTO</span>;</p>

<p class="MsoListNumberCxSpMiddle">3. 
Объект, обеспечивающий низкоуровневую запись
данных в формате JSON – <span class="Term">ЗаписьJSON</span>.</p>

<p class="MsoListNumberCxSpLast">4. 
Объект настроек сериализации <span class="Term">НастройкиСериализацииJSON</span>.</p>

<p class="MsoNormal">Собственно
сериализация выполняется с помощью метода <span class="Term">ЗаписатьJSON()</span> объекта <span class="Term">СериализаторXDTO</span>. Рассмотрим пример
сериализации данных типа <span class="Term">СправочникОбъект</span>. В качестве примера
используется справочник <span class="Term">Валюты</span>, который содержит поля <span class="Term">Курс</span> (типа <span class="Term">Число</span>) и <span class="Term">ДатаКурса</span> (типа <span class="Term">Дата</span>):</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">Данные <span class="operator">=</span> Справочники<span class="operator">.</span>Валюты<span class="operator">.</span>НайтиПоКоду<span class="operator">(</span><span class="string">&quot;978&quot;</span><span class="operator">)</span><span class="operator">.</span>ПолучитьОбъект<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
Запись <span class="operator">=</span> <span class="keyword">Новый</span> ЗаписьJSON<span class="operator">;</span>
Запись<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;c:\temp\simpleXDTOWrite.json&quot;</span><span class="operator">)</span><span class="operator">;</span>
СериализаторXDTO<span class="operator">.</span>ЗаписатьJSON<span class="operator">(</span>Запись<span class="operator">,</span> Данные<span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">В
результате работы данный пример сформирует следующий JSON-документ:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
{
&quot;#value&quot;: {
&quot;Ref&quot;: &quot;5b65bd8e-ea70-11e4-af93-e03f49b16069&quot;,
&quot;DeletionMark&quot;: false,
&quot;Code&quot;: &quot;978&quot;,
&quot;Description&quot;: &quot;Евро&quot;,
&quot;Курс&quot;: 54.659,
&quot;ДатаКурса&quot;: &quot;2015-04-25T00:00:00&quot;
}
}
</pre>

<p class="MsoNormalCxSpFirst">Сериализация
значений типа <span class="Term">Дата</span>
выполняется в формате ISO (определяется механизмом XDTO) и не управляется при
записи данных. Также не поддерживается использование функции преобразования при
операции сериализации, в отличие от потоковой (см. <a href="#_ref417985143">здесь</a>) и объектной (см. <a href="#_ref417985150">здесь</a>) техник.</p>

<p class="MsoNormalCxSpLast">Также
следует помнить о следующей особенности: при записи объекта не формируется его
тип, поэтому после JSON-сериализации XDTO-объекта отсутствует возможность
выполнить десериализацию без указания типа считываемого объекта. Предыдущий
пример сериализации элемента справочника <span class="Term">Валюты</span> будет невозможно десериализовать без
явного указания типа значения. Чтобы упростить ситуацию, можно воспользоваться
параметром <span class="Term">НазначениеТипаXML</span>
метода <span class="Term">ЗаписатьJSON()</span>
объекта <span class="Term">СериализаторXDTO</span>.
Если в качестве значения этого параметра указать <span class="Term">НазначениеТипаXML.Явное</span>, то появится
возможность выполнить десериализацию без явного указания типа, а сформированный
файл будет выглядеть следующим образом:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
{
&quot;#type&quot;: &quot;jcfg:CatalogObject.Валюты&quot;,
&quot;#value&quot;: {
&quot;Ref&quot;: &quot;5b65bd8e-ea70-11e4-af93-e03f49b16069&quot;,
&quot;DeletionMark&quot;: false,
&quot;Code&quot;: &quot;978&quot;,
&quot;Description&quot;: &quot;Евро&quot;,
&quot;Курс&quot;: 54.659,
&quot;ДатаКурса&quot;: &quot;2015-04-25T00:00:00&quot;
}
}
</pre>

<p class="MsoNormalCxSpFirst">В
данном примере особого внимания заслуживает элемент <span class="Term">#type</span>, который и описывает тип текущего
элемента. Описание префиксов пространств имен см. <A href="/db/content/v8310doc/src/руководство разработчика/приложение 13. префиксы пространств имен при json-сериализации.htm?_=1496848987#_ref417661668">здесь</a>.</p>

<p class="MsoNormalCxSpLast">Общие
принципы JSON-сериализации объектов XDTO идентичны XML-сериализации:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
Структура данных соответствует структуре XML-документа.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
Имеются незначительные отличия, связанные с
особенностями хранения типов и представлением массивов в JSON:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
Порядок и состав свойств определен в модели XDTO
и не может быть изменен.</p>

<p class="MsoListBullet2CxSpMiddle">&#9679; 
Если тип записываемого значения однозначно определяется
из типа, определенного в соответствующем свойстве XDTO-модели, то записывается
только значение без идентификации типа.</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
Если тип записываемого значения неоднозначно определяется
из типа, определенного в соответствующем свойстве XDTO-модели (например,
значение составного типа), то значение будет записано в виде сложного объекта
JSON с отдельными свойствами для типа (свойство <span class="Term">#type</span>) и значения (свойство <span class="Term">#value</span>). В следующем примере записаны эквивалентные
варианты представления значения типа <span class="Term">Строка</span>. Первая запись используется при
неоднозначном определении типа, вторая – при однозначном:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
Первая запись
{
&quot;#type&quot;: &quot;jxs:string&quot;,
&quot;#value&quot;: &quot;Строка с примером&quot;
}
Вторая запись
&quot;Строка с примером&quot;
</pre>

<p class="MsoNormal">JSON-сериализация
объектов XDTO имеет ряд особенностей (по сравнению с XML-сериализацией):</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
Коллекции значений (например, значения типа <span class="Term">Массив</span>, <span class="Term">Структура</span> и т. д.) всегда
записываются виде массива JSON.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
Тип значения реквизита записывается в
специальное свойство JSON с именем <span class="Term">#type</span>.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
Пространство имен типов записывается в
специальное свойство JSON с именем <span class="Term">#ns</span>:</p>

<p class="MsoListBullet2">&#9679; 
Для встроенных в платформу пространств имен типы
записываются без использования свойства <span class="Term">#ns</span>, но с указанием префикса:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
jxс:ChartOfCharacteristicTypesObject.ДемоПланВидовХарактеристик
jxs:string
jxs:decimal
</pre>

<p class="Indentlist2">Соответствие
префиксов и пространств имен см. <A href="/db/content/v8310doc/src/руководство разработчика/приложение 13. префиксы пространств имен при json-сериализации.htm?_=1496848987#_ref417661668">здесь</a>.</p>

<p class="MsoListBullet2">&#9679; 
Если встретится схема, которая не имеет
префикса, то имя схемы явно записывается с помощью свойства <span class="Term">#ns</span>:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
{
&quot;#ns&quot;: &quot;http://mycompany.com/data/enterprise/myscheme&quot;,
&quot;#type&quot;: &quot;СпециальныйОбъект&quot;,
&quot;#value&quot;: …
}
</pre>

<p class="MsoNormal">Значения
<span class="Term">Неопределено</span>
и <span class="Term">NULL</span>
сериализуются особым образом:</p>

<p class="MsoListNumber">1.  <span class="Term">Неопределено</span>:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
{
&quot;#type&quot;: &quot;jv8:Null&quot;,
&quot;#value&quot;: &quot;&quot;
}
</pre>

<p class="MsoListNumber">2.  <span class="Term">NULL</span>:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
{
&quot;ИмяРеквизита&quot;: null
}
</pre>

<p class="MsoNormal">С
помощью JSON возможно выполнить сериализацию XDTO-объектов, которые не
соответствуют какой-либо схеме. В этом случае используется явное описание типов
реквизитов, одноименные свойства не будут объединяться в массив, а будут
выводиться в JSON-документ поэлементно, в соответствии с XDTO-объектом.</p>

<p class="Lang-subheader">Пример:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
{
    &quot;#type&quot;: &quot;jxs:anyType&quot;,
    &quot;#value&quot;: {
        &quot;Filters&quot;: {
            &quot;Filter&quot;: {
                &quot;Name&quot;: &quot;Recorder&quot;,
                &quot;Value&quot;: {
                    &quot;#type&quot;: &quot;jxs:anySimpleType&quot;,
                    &quot;#value&quot;: &quot;acc2d259-c8f3-11e2-b5da-5404a6a68c42&quot;
                }
            }
        },
        &quot;Record&quot;: {
            &quot;Recorder&quot;: {
                &quot;#type&quot;: &quot;jxs:anySimpleType&quot;,
                &quot;#value&quot;: &quot;acc2d259-c8f3-11e2-b5da-5404a6a68c42&quot;
            },
            &quot;Period&quot;: {
                &quot;#type&quot;: &quot;jxs:anySimpleType&quot;,
                &quot;#value&quot;: &quot;2012-09-08T00:00:00&quot;
            },
            &quot;Active&quot;: {
                &quot;#type&quot;: &quot;jxs:anySimpleType&quot;,
                &quot;#value&quot;: &quot;true&quot;
            },
        },
        &quot;Record&quot;: {
            &quot;Recorder&quot;: {
                &quot;#type&quot;: &quot;jxs:anySimpleType&quot;,
                &quot;#value&quot;: &quot;acc2d259-c8f3-11e2-b5da-5404a6a68c42&quot;
            },
            &quot;Period&quot;: {
                &quot;#type&quot;: &quot;jxs:anySimpleType&quot;,
                &quot;#value&quot;: &quot;2012-09-08T00:00:00&quot;
            },
            &quot;Active&quot;: {
                &quot;#type&quot;: &quot;jxs:anySimpleType&quot;,
                &quot;#value&quot;: &quot;true&quot;
            },
        },
    }
}
</pre>

<a id="TI000001581" class="bookmark" name="issogl3_16.2.3.3_чтение"><h4>16.2.3.3. Чтение</h4></a>

<p class="MsoNormal">В
общем случае, чтение XDTO-объекта из JSON-документа аналогично записи. Чтение
выполняется с помощью механизма чтения XDTO-объектов из XML-файла, поэтому чтение
выполняется со следующими ограничениями:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
Возможно чтение только тех объектов, для которых
существует XDTO-сериализация.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
Свойства в JSON-документе должны следовать в том
же порядке, как и в XDTO-объекте.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
В случае если читаемый объект не соответствует схеме –
будет вызвано исключение.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
Имеется возможность выполнять чтение
произвольного JSON-документа в объект XDTO (<span class="Term">ОбъектXDTO</span>) с помощью фабрики XDTO (<span class="Term">ФабрикаXDTO</span>). Такое чтение возможно в том
случае, если:</p>

<p class="MsoListBullet2CxSpFirst">&#9679; 
фабрика XDTO, с помощью которой выполняется
чтение, «знает» о типах, которые присутствуют в JSON-документе, из которого
производится чтение.</p>

<p class="MsoListBullet2CxSpLast">&#9679; 
все элементы JSON указаны без явного указания
типов и элементов, специфичных для JSON-документов, формируемых при
сериализации объектов XDTO.</p>

<p class="Indentlist">Выполнить
чтение JSON-документа в том случае, если в нем используются типы, которые
неизвестны фабрике XDTO, с помощью которой выполняется чтение документа –
невозможно.</p>

<p class="MsoNormal">Рассмотрим
пример чтения некоторого JSON-документа, например, полученного при работе
примера работы со справочником <span class="Term">Валюты</span> из предыдущего раздела
(см. <a href="#_ref417988598">здесь</a>).</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
Чтение = Новый ЧтениеJSON;
Чтение.ОткрытьФайл(&quot;c:\temp\simpleXDTOWrite.json&quot;);
Данные = СериализаторXDTO.ПрочитатьJSON(Чтение);
Чтение.Закрыть();
</pre>

<p class="MsoNormal">В
результате работы примера в переменно <span class="Term">Данные</span> будет помещен объект типа <span class="Term">СправочникОбъект.Валюты</span> для валюты с кодом <span class="Term">978</span>. Однако данное поведение будет наблюдаться
только в том случае, если при выполнении JSON-сериализация значение параметра <span class="Term">НазначениеТипаXML</span> было установлено в значение <span class="Term">Явное</span>. В противном случае при попытке чтения
(как указано выше) будет вызвано исключение. При чтении объекта с неявным
указанием типа объекта, читаемый тип можно передать в виде параметра метода <span class="Term">ПрочитатьJSON()</span>. В этом случае пример будет
выглядеть следующим образом:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
Чтение = Новый ЧтениеJSON;
Чтение.ОткрытьФайл(&quot;c:\temp\simpleXDTOWrite.json&quot;);
Данные = СериализаторXDTO.ПрочитатьJSON(Чтение, Тип(&quot;СправочникОбъект.Валюты&quot;));
Чтение.Закрыть();
</pre>

<p class="MsoNormal">При
обмене данными между прикладными решениями с помощью объектов XDTO может
возникать задача, когда требуется выполнить некоторую предобработку данных,
которые поступают в пакете обмена. Например, заменить любое значение некоторого
типа на фиксированное значение того же типа. Для упрощения такой предобработки
предназначена функция восстановления. Имя функции восстановления передается в
функцию чтения из JSON-документа для сериализатора или фабрики XDTO. При чтении
объекта функция восстановления будет вызываться при десериализации значений
следующих типов:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
<span class="Term">Булево</span>;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Число</span>;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Строка</span>;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">Дата</span>;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">УникальныйИдентификатор</span>;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">ДвоичныеДанные</span>;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
<span class="Term">ХранилищеЗначения</span>;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
Значения перечислений;</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
Значения системных перечислений;</p>

<p class="MsoListBulletCxSpLast">&#9679; 
Ссылки на объекты базы данных.</p>

<p class="MsoNormalCxSpFirst">Для
значений <span class="Term">Неопределено</span>
функция восстановления не вызывается.</p>

<p class="MsoNormalCxSpLast">При
разработке функции восстановления необходимо помнить, что в этой функции можно
заменить значение, которое считано из JSON-документа, но нельзя изменить тип
считываемого объекта. Функция восстановления также не будет вызываться для служебных
свойств, которые создаются и используются системой «1С:Предприятие», например, <span class="Term">#type</span>, <span class="Term">#ns</span> и т. д.</p>

<a name="_ref417985143"></a><a id="TI000001498" class="bookmark" name="issogl2_16.2.4_потоковая_техника_работы"><h3>16.2.4. Потоковая техника работы</h3></a>

<a id="TI000001499" class="bookmark" name="issogl3_16.2.4.1_общая_информация"><h4>16.2.4.1. Общая информация</h4></a>

<p class="MsoNormal">Потоковая
техника работы с документом ориентирована на то, что документ целиком не
загружается в память и обрабатывается последовательно, от элемента к элементу.
Например, если надо прочитать только какой-то объект из JSON-документа, то
потоковая техника может дать существенный выигрыш, особенно в том случае, если
требуемый элемент находится в начале обрабатываемого документа.</p>

<a name="_ref400125269"></a><a id="TI000001500" class="bookmark" name="issogl3_16.2.4.2_запись"><h4>16.2.4.2. Запись</h4></a>

<p class="MsoNormalCxSpFirst">Для
того чтобы выполнить потоковую запись JSON-документа, необходимы записываемые
данные и объект <span class="Term">ЗаписьJSON</span>.
При этом следует понимать, что формирование корректной структуры JSON-документа
полностью лежит на прикладном разработчике, который формирует документ. Для
упрощения такого контроля объект <span class="Term">ЗаписьJSON</span>
имеет свойство <span class="Term">ПроверятьСтруктуру</span>.</p>

<p class="MsoNormalCxSpLast">Рассмотрим
простой пример записи документа:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">ПараметрыJSON <span class="operator">=</span> <span class="keyword">Новый</span> ПараметрыЗаписиJSON<span class="operator">(</span>ПереносСтрокJSON<span class="operator">.</span>Авто<span class="operator">,</span> <span class="string">&quot; &quot;</span><span class="operator">,</span> <span class="keyword">Истина</span><span class="operator">)</span><span class="operator">;</span>
Запись <span class="operator">=</span> <span class="keyword">Новый</span> ЗаписьJSON<span class="operator">;</span>
Запись<span class="operator">.</span>ПроверятьСтруктуру <span class="operator">=</span> <span class="keyword">Истина</span><span class="operator">;</span>
Запись<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;c:\temp\streamWrite.json&quot;</span><span class="operator">,</span> <span class="operator">,</span> <span class="operator">,</span> ПараметрыJSON<span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьНачалоОбъекта<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьИмяСвойства<span class="operator">(</span><span class="string">&quot;ДлинаЗаписи&quot;</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьЗначение<span class="operator">(</span><span class="number">20</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьИмяСвойства<span class="operator">(</span><span class="string">&quot;Товар&quot;</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьНачалоОбъекта<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьИмяСвойства<span class="operator">(</span><span class="string">&quot;Код&quot;</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьЗначение<span class="operator">(</span><span class="string">&quot;0020&quot;</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьИмяСвойства<span class="operator">(</span><span class="string">&quot;Наименование&quot;</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьЗначение<span class="operator">(</span><span class="string">&quot;Товар&quot;</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьКонецОбъекта<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьИмяСвойства<span class="operator">(</span><span class="string">&quot;МассивЧисел&quot;</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьНачалоМассива<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьЗначение<span class="operator">(</span><span class="number">3</span><span class="number">.</span><span class="number">141592654</span><span class="operator">,</span> <span class="keyword">Истина</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьЗначение<span class="operator">(</span><span class="number">2</span><span class="number">.</span><span class="number">718281828</span><span class="operator">,</span> <span class="keyword">Ложь</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьКонецМассива<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьКонецОбъекта<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">В
результате исполнения этого программного кода будет сформирован следующий
документ:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
{
 &quot;ДлинаЗаписи&quot;: 20,
 &quot;Товар&quot;: {
  &quot;Код&quot;: &quot;0020&quot;,
  &quot;Наименование&quot;: &quot;Товар&quot;
 },
 &quot;МассивЧисел&quot;: [
  3.141592654E0,
  2.718281828
 ]
}
</pre>

<p class="MsoNormal">Такой
формат документа удобен для визуального просмотра, но занимает больше места.
Можно изменить значение первого параметра конструктора <span class="Term">ПараметрыЗаписиJSON</span> на значение <span class="Term">ПереносСтрокJSON.Нет</span> и результирующий документ
примет такой вид (разница составит примерно 20%):</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">{<span class="string">&quot;ДлинаЗаписи&quot;</span>:20<span class="operator">,</span><span class="string">&quot;Товар&quot;</span>:{<span class="string">&quot;Код&quot;</span>:<span class="string">&quot;0020&quot;</span><span class="operator">,</span><span class="string">&quot;Наименование&quot;</span>:<span class="string">&quot;Товар&quot;</span>}<span class="operator">,</span><span class="string">&quot;МассивЧисел&quot;</span>:<span class="operator">[</span><span class="number">3</span><span class="number">.</span><span class="number">141592654E0</span><span class="operator">,</span><span class="number">2</span><span class="number">.</span><span class="number">718281828</span><span class="operator">]</span>}</pre>

<p class="MsoNormal">Если
необходимо получить JSON-документ без формирования файла, то можно использовать
метод <span class="Term">УстановитьСтроку()</span>
объекта <span class="Term">ЗаписьJSON</span>.
После вызова этого метода, для получения строки со сформированным
JSON-документом, достаточно просто завершить запись документа методом <span class="Term">Закрыть()</span> объекта <span class="Term">ЗаписьJSON</span>:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">ПараметрыJSON <span class="operator">=</span> <span class="keyword">Новый</span> ПараметрыЗаписиJSON<span class="operator">(</span>ПереносСтрокJSON<span class="operator">.</span>Нет<span class="operator">,</span> <span class="string">&quot; &quot;</span><span class="operator">,</span> <span class="keyword">Истина</span><span class="operator">)</span><span class="operator">;</span>
Запись <span class="operator">=</span> <span class="keyword">Новый</span> ЗаписьJSON<span class="operator">;</span>
Запись<span class="operator">.</span>УстановитьСтроку<span class="operator">(</span>ПараметрыJSON<span class="operator">)</span><span class="operator">;</span>
…
Документ <span class="operator">=</span> Запись<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">Теперь
данный документ (из переменной <span class="Term">Документ</span>)
можно передавать, например, в тело HTTP-запроса.</p>

<a id="TI000001501" class="bookmark" name="issogl3_16.2.4.3_чтение"><h4>16.2.4.3. Чтение</h4></a>

<p class="MsoNormalCxSpFirst">Потоковое
чтение JSON-документа выполняется аналогично его записи: прикладной разработчик
в цикле читает следующий элемент, определяет, что считано и обрабатывает
считываемые данные.</p>

<p class="MsoNormalCxSpLast">Примитивный
случай потокового чтения документа может выглядеть следующим образом:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">Чтение <span class="operator">=</span> <span class="keyword">Новый</span> ЧтениеJSON<span class="operator">;</span>
Чтение<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;c:\temp\streamWrite.json&quot;</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">Пока</span> Чтение<span class="operator">.</span>Прочитать<span class="operator">(</span><span class="operator">)</span> <span class="keyword">Цикл</span>
    Сообщить<span class="operator">(</span><span class="string">&quot;Тип текущего элемента &quot;</span> <span class="operator">+</span> Чтение<span class="operator">.</span>ТипТекущегоЗначения<span class="operator">)</span><span class="operator">;</span>
    <span class="keyword">Если</span> Чтение<span class="operator">.</span>ТипТекущегоЗначения <span class="operator">=</span> ТипЗначенияJSON<span class="operator">.</span>ИмяСвойства <span class="keyword">Тогда</span>
        Сообщить<span class="operator">(</span><span class="string">&quot;Имя = &quot;</span> <span class="operator">+</span> Чтение<span class="operator">.</span>ТекущееЗначение<span class="operator">)</span><span class="operator">;</span>
    <span class="keyword">КонецЕсли</span><span class="operator">;</span>
    <span class="keyword">Если</span> Чтение<span class="operator">.</span>ТипТекущегоЗначения <span class="operator">=</span> ТипЗначенияJSON<span class="operator">.</span>Булево <span class="keyword">Или</span>
            Чтение<span class="operator">.</span>ТипТекущегоЗначения <span class="operator">=</span> ТипЗначенияJSON<span class="operator">.</span>Строка <span class="keyword">Или</span> 
            Чтение<span class="operator">.</span>ТипТекущегоЗначения <span class="operator">=</span> ТипЗначенияJSON<span class="operator">.</span>Число <span class="keyword">Или</span> 
            Чтение<span class="operator">.</span>ТипТекущегоЗначения <span class="operator">=</span> ТипЗначенияJSON<span class="operator">.</span>Комментарий <span class="keyword">Тогда</span>
        Сообщить<span class="operator">(</span><span class="string">&quot;Значение = &quot;</span> <span class="operator">+</span> Чтение<span class="operator">.</span>ТекущееЗначение<span class="operator">)</span><span class="operator">;</span>
    <span class="keyword">КонецЕсли</span><span class="operator">;</span>
<span class="keyword">КонецЦикла</span><span class="operator">;</span>
Чтение<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">Тогда
при чтении документа, сформированного при рассмотрении потоковой записи
JSON-документа (см. <a href="#_ref400125269">здесь</a>), будет сформирован следующий результат:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
Тип текущего элемента Начало объекта
Тип текущего элемента Имя свойства
Имя = ДлинаЗаписи
Тип текущего элемента Число
Значение = 20
Тип текущего элемента Имя свойства
Имя = Товар
Тип текущего элемента Начало объекта
Тип текущего элемента Имя свойства
Имя = Код
Тип текущего элемента Строка
Значение = 0020
Тип текущего элемента Имя свойства
Имя = Наименование
Тип текущего элемента Строка
Значение = Товар
Тип текущего элемента Конец объекта
Тип текущего элемента Имя свойства
Имя = МассивЧисел
Тип текущего элемента Начало массива
Тип текущего элемента Число
Значение = 3,141592654
Тип текущего элемента Число
Значение = 2,718281828
Тип текущего элемента Конец массива
Тип текущего элемента Конец объекта
</pre>

<a name="_ref400445950"></a><a id="TI000001502" class="bookmark" name="issogl2_16.2.5_совмещение_техник"><h3>16.2.5. Совмещение техник</h3></a>

<p class="MsoNormalCxSpFirst">Для
упрощения работы с JSON, можно совмещать различные техники при формировании
одного документа. Например, необходимо сформировать документ, который содержит
в себе некоторый набор структур и массив. В этом случае можно все оформление
документа выполнять с помощью потоковой техники, а уже готовые структуры и
массив записывать с помощью объектной техники. Важно только обеспечить
корректную структуру документа перед началом объектной записи.</p>

<p class="MsoNormalCxSpLast">Приведем
пример совмещения техник на следующем примере:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
В ответ на запрос внешней системы, этой системе
необходимо возвращать список заказов.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
Список должен содержать дату формирования и
набор заказов (соответствующий некоторому критерию).</p>

<p class="MsoListBulletCxSpLast">&#9679; 
Каждый заказ описывается следующими параметрами:</p>

<p class="MsoListNumber2CxSpFirst">1. 
Номер заказа;</p>

<p class="MsoListNumber2CxSpMiddle">2. 
Дата формирования заказа;</p>

<p class="MsoListNumber2CxSpMiddle">3. 
Контрагент по заказу;</p>

<p class="MsoListNumber2CxSpLast">4. 
Уникальный идентификатор заказа, по которому
впоследствии можно получить всю информацию по заказу.</p>

<p class="MsoNormal">Фрагмент
кода на встроенном языке, который формирует JSON-документ, будет иметь
следующий вид:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">НастройкиСериализации <span class="operator">=</span> <span class="keyword">Новый</span> НастройкиСериализацииJSON<span class="operator">;</span>
НастройкиСериализации<span class="operator">.</span>ВариантЗаписиДаты <span class="operator">=</span> ВариантЗаписиДатыJSON<span class="operator">.</span>УниверсальнаяДата<span class="operator">;</span>
НастройкиСериализации<span class="operator">.</span>ФорматСериализацииДат <span class="operator">=</span> ФорматДатыJSON<span class="operator">.</span>ISO<span class="operator">;</span>
НастройкиСериализации<span class="operator">.</span>СериализовыватьМассивыКакОбъекты <span class="operator">=</span> <span class="keyword">Истина</span><span class="operator">;</span>
ПараметрыJSON <span class="operator">=</span> <span class="keyword">Новый</span> ПараметрыЗаписиJSON<span class="operator">(</span>ПереносСтрокJSON<span class="operator">.</span>Авто<span class="operator">,</span> <span class="string">&quot; &quot;</span><span class="operator">,</span> <span class="keyword">Истина</span><span class="operator">)</span><span class="operator">;</span>
Запись <span class="operator">=</span> <span class="keyword">Новый</span> ЗаписьJSON<span class="operator">;</span>
Запись<span class="operator">.</span>ПроверятьСтруктуру <span class="operator">=</span> <span class="keyword">Истина</span><span class="operator">;</span>
Запись<span class="operator">.</span>ОткрытьФайл<span class="operator">(</span><span class="string">&quot;c:\temp\combinedWrite.json&quot;</span><span class="operator">,</span> <span class="operator">,</span> <span class="operator">,</span> ПараметрыJSON<span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьНачалоОбъекта<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьИмяСвойства<span class="operator">(</span><span class="string">&quot;ДатаФормирования&quot;</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьЗначение<span class="operator">(</span>ЗаписатьДатуJSON<span class="operator">(</span>КогдаСформировано<span class="operator">,</span> ФорматДатыJSON<span class="operator">.</span>ISO<span class="operator">,</span> ВариантЗаписиДатыJSON<span class="operator">.</span>УниверсальнаяДата<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьИмяСвойства<span class="operator">(</span><span class="string">&quot;Заказы&quot;</span><span class="operator">)</span><span class="operator">;</span>
Заказы <span class="operator">=</span> <span class="keyword">Новый</span> Массив<span class="operator">;</span>
<span class="keyword">Для</span> <span class="keyword">каждого</span> Заказ <span class="keyword">Из</span> СписокЗаказов <span class="keyword">Цикл</span>
    ОписаниеЗаказа <span class="operator">=</span> <span class="keyword">Новый</span> Структура<span class="operator">(</span><span class="string">&quot;Ссылка, Номер, Дата, Контрагент&quot;</span><span class="operator">)</span><span class="operator">;</span>
    ОписаниеЗаказа<span class="operator">.</span>Ссылка <span class="operator">=</span> Строка<span class="operator">(</span>Заказ<span class="operator">.</span>Ссылка<span class="operator">)</span><span class="operator">;</span>
    ОписаниеЗаказа<span class="operator">.</span>Номер <span class="operator">=</span> Заказ<span class="operator">.</span>Номер<span class="operator">;</span>
    ОписаниеЗаказа<span class="operator">.</span>Дата <span class="operator">=</span> Заказ<span class="operator">.</span>Дата<span class="operator">;</span>
    ОписаниеЗаказа<span class="operator">.</span>Контрагент <span class="operator">=</span> Строка<span class="operator">(</span>Заказ<span class="operator">.</span>Контрагент<span class="operator">)</span><span class="operator">;</span>
    Заказы<span class="operator">.</span>Добавить<span class="operator">(</span>ОписаниеЗаказа<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">КонецЦикла</span><span class="operator">;</span>
ЗаписатьJSON<span class="operator">(</span>Запись<span class="operator">,</span> Заказы<span class="operator">,</span> НастройкиСериализации<span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>ЗаписатьКонецОбъекта<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
Запись<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">При
исполнении данного кода предполагается, что:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
Переменная <span class="Term">КогдаСформировано</span> содержит значение типа <span class="Term">Дата</span>. Содержит дату и время формирования
JSON-документа.</p>

<p class="MsoListBulletCxSpLast">&#9679; 
Переменная <span class="Term">СписокЗаказов</span> является массивом ссылок на
документы заказов.</p>

<p class="MsoNormal">Исполнение
данного код приведет к формированию следующего JSON-документа:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
{
    &quot;ДатаФормирования&quot;: &quot;2014-10-06T12:57:35Z&quot;,
    &quot;Заказы&quot;: {
        &quot;0&quot;: {
        &quot;Ссылка&quot;: &quot;f4d1495a-02b5-4d56-92c6-840c11dfb592&quot;,
        &quot;Номер&quot;: 234,
        &quot;Дата&quot;: &quot;2014-09-30T20:00:00Z&quot;,
        &quot;Контрагент&quot;: &quot;Иванов И.И.&quot;
        },
    &quot;1&quot;: {
        &quot;Ссылка&quot;: &quot;ee821799-2d57-475e-a330-f414e53b8bda&quot;,
        &quot;Номер&quot;: 436,
        &quot;Дата&quot;: &quot;2014-09-24T20:00:00Z&quot;,
        &quot;Контрагент&quot;: &quot;Петров А.П.&quot;
        },
    &quot;2&quot;: {
        &quot;Ссылка&quot;: &quot;e058a5a8-3c0d-453b-8b1c-963a35fe2b7a&quot;,
        &quot;Номер&quot;: 118,
        &quot;Дата&quot;: &quot;2014-08-31T20:00:00Z&quot;,
        &quot;Контрагент&quot;: &quot;Иванов И.И.&quot;
        }
    }
}
</pre>

<p class="MsoNormalCxSpFirst">Изменяя
значения параметров объектов <span class="Term">НастройкиСериализации</span>
и <span class="Term">ПараметрыJSON</span>,
а также манипулируя параметрами метода <span class="Term">ЗаписатьДатуJSON()</span>, можно изменять
результирующий JSON-документ для максимального соответствия «ожиданиям»
принимающей системы.</p>

<p class="MsoNormalCxSpMiddle"> </p>

<br>

<a name="_ref448915370"></a><a id="TI000001825" class="bookmark" name="issogl1_16.3_работа_с_двоичными_данными"><h2>16.3. Работа с двоичными данными</h2></a>

<a name="_ref468709852"></a><a name="_ref468709851"></a><a id="TI000001826" class="bookmark" name="issogl2_16.3.1_общая_информация"><h3>16.3.1. Общая информация</h3></a>

<p class="MsoNormalCxSpFirst">При
реализации прикладных решений возможны ситуации, когда необходимо анализировать
различные двоичные данные. Например, требуется по сигнатуре определить тип
файла или выполнить какие-либо манипуляции с картинкой. Для работы с двоичными
данными «1С:Предприятие» предоставляет специальные программные интерфейсы.
Далее будут рассмотрены возможности по работе с двоичными данными.</p>

<p class="MsoNormalCxSpMiddle">Собственно
хранение двоичных данных во время работы системы выполняется с помощью
одноименного объекта – <span class="Term">ДвоичныеДанные</span>.
С помощью этого объекта можно прочитать данные любого файла, не обращая
внимания на формат этого файла. Но модификация данных с помощью данного объекта
не поддерживается. Единственным исключением можно считать возможность разбить
двоичные данные на несколько частей указанного размера (метод <span class="Term">РазделитьДвоичныеДанные()</span>) и выполнить
обратную операцию (метод <span class="Term">СоединитьДвоичныеДанные()</span>).</p>

<p class="MsoNormalCxSpMiddle">Вся
дальнейшая работа с двоичными данными базируется на понятии <span class="Bold">потока</span>. <span class="Bold">Поток</span> –
это логическое обобщение произвольного (в общем случае) источника данных
(объект <span class="Term">Поток</span>). Система не предоставляет возможности
создать самостоятельный объект <span class="Term">Поток</span>, который не связан
с каким-либо источником. Но существуют производные объекты, которые можно
создать – это поток, связанный с файлом на диске (объект <span class="Term">ФайловыйПоток</span>)
или поток, созданный в памяти (объект <span class="Term">ПотокВПамяти</span>).
Поток предоставляет возможность как чтения данных, так и их записи. Для
определения возможности выполнения тех или иных операций, у потока (и
производных объектов) существуют специальные методы, позволяющие определить,
какие операции доступны с данным потоком (методы <span class="Term">ДоступнаЗапись()</span>,
<span class="Term">ДоступноЧтение()</span>, <span class="Term">ДоступноИзменениеПозиции()</span>).</p>

<p class="MsoNormalCxSpMiddle">Если
необходимо работать с потоком на более высоком уровне, в частности, выполнять
чтение/запись таких данных, как число (разной разрядности) или строка, то для
этого предназначены объекты <span class="Term">ЧтениеДанных</span>/<span class="Term">ЗаписьДанных</span>. С помощью этих объектов имеется
возможность более структурировано подходить к двоичным данным, которые расположены
в потоке. Так, например, зная формат какого-либо файла, можно достаточно
комфортно выполнять чтение такого файла, получая из заголовков нужные данные
(которые, как правило, представлены типами число и строка), пропуская не нужные
блоки данных и загружая для обработки нужные.</p>

<p class="MsoNormalCxSpLast">Общую
схему работы с двоичными данными можно представить следующим образом:</p>

<p class="MsoListNumberCxSpFirst">1.  Выполняется
получение потока.</p>

<p class="MsoListNumberCxSpMiddle">2. 
Создается объект <span class="Term">ЧтениеДанных</span> или <span class="Term">ЗаписьДанных</span>.</p>

<p class="MsoListNumberCxSpMiddle">3. 
С помощью объекта, созданного в п.2, выполняются
требуемые действия.</p>

<p class="MsoListNumberCxSpMiddle">4. 
Закрывается объект, созданный в п.2.</p>

<p class="MsoListNumberCxSpMiddle">5. 
Если никаких операций больше выполнять не
требуется – закрывается поток, полученный в п.1.</p>

<p class="MsoListNumberCxSpLast">6. 
Если требуется продолжить работу с потоком, то можно
выполнить установку новой позиции в потоке (если эта операция поддерживается) и
продолжить работу, начиная с п.2.</p>

<p class="MsoNormalCxSpFirst">Стоит
отметить, что имеется возможность объединить пп.1 и 2. Другими словами, система
предоставляет возможность создания объектов <span class="Term">ЧтениеДанных</span>/<span class="Term">ЗаписьДанных</span>
сразу из, например, объекта <span class="Term">ДвоичныеДанные</span>.</p>

<p class="MsoNormalCxSpMiddle">Для
выполнения различных операций с двоичными данными система предоставляет
возможность получить некоторую часть потока в качестве обособленного фрагмента
с произвольным (побайтовым) доступом (объект <span class="Term">БуферДвоичныхДанных</span>).
Размер буфера задается при создании и не может быть изменен в дальнейшем. При
работе с буфером двоичных данных имеется возможность работать с числами разной
разрядности как с единым целым. При этом имеется возможность указания порядка
следования байтов в словах: «младший-старший» (little endian) или
«старший-младший» (big endian). Также имеется возможность разбиения одного
буфера на несколько и объединения нескольких буферов двоичных данных в один
результирующий буфер.</p>

<p class="MsoNormalCxSpMiddle">Важно
отметить, что работа с буфером двоичных данных позволяет существенно упростить
реализацию в том случае, если работа с двоичными данными реализуется на стороне
клиентского приложения в асинхронном режиме. В этом случае чтение данных в
буфер будет выполняться асинхронной операцией, а работа с данными буфера
является синхронной.</p>

<p class="MsoNormalCxSpLast">Работа
с двоичными данными доступна на стороне клиентского (включая веб-клиент)
приложения, на стороне сервера системы «1С:Предприятие», а также в синхронной и
асинхронной схемах работы. Дальнейшие примеры будут использовать синхронную
схему работы.</p>

<a name="_ref446689693"></a><a id="TI000001827" class="bookmark" name="issogl2_16.3.2_чтение_двоичных_данных"><h3>16.3.2. Чтение двоичных данных</h3></a>

<p class="MsoNormal">В
качестве примера чтения двоичных данных будет рассмотрена задача определения
корректного формата файла, который выбрали в системе для дальнейшего использования.
В роли проверяемого файла будет использоваться .wav-файл с аудио-данными. Для
хранения .wav-файлов используется Resource Interchange File Format (RIFF),
описание которого приведено по ссылке: <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee415713.aspx" target="_blank">https://msdn.microsoft.com/en-us/library/windows/desktop/ee415713.aspx</a> (на английском языке). Для примера чтения
будут использоваться следующие данные о формате:</p>

<p class="MsoListNumberCxSpFirst">1.  Первые
4 байта файла содержат идентификатор формата: <span class="Term">RIFF</span>.</p>

<p class="MsoListNumberCxSpMiddle">2. 
Следующие 4 байта содержат размер собственно
аудио данных с порядком следования байт little-endian.</p>

<p class="MsoListNumberCxSpLast">3. 
Следующие 4 байта содержат текстовый тип
используемых данных: <span class="Term">WAVE</span>.</p>

<p class="MsoNormal">Для
выполнения этих действий потребуется следующий код на встроенном языке:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">Чтение <span class="operator">=</span> <span class="keyword">Новый</span> ЧтениеДанных<span class="operator">(</span>ИмяФайла<span class="operator">,</span> <span class="operator">,</span> ПорядокБайтов<span class="operator">.</span>LittleEndian<span class="operator">)</span><span class="operator">;</span>
ФорматФайла <span class="operator">=</span> Чтение<span class="operator">.</span>ПрочитатьСимволы<span class="operator">(</span><span class="number">4</span><span class="operator">)</span><span class="operator">;</span>
РазмерДанных <span class="operator">=</span> Чтение<span class="operator">.</span>ПрочитатьЦелое32<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
ТипФайла <span class="operator">=</span> Чтение<span class="operator">.</span>ПрочитатьСимволы<span class="operator">(</span><span class="number">4</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">Если</span> ФорматФайла <span class="operator">&lt;</span><span class="operator">&gt;</span> <span class="string">&quot;RIFF&quot;</span> <span class="keyword">Тогда</span>
    Сообщить<span class="operator">(</span><span class="string">&quot;Это не файл формата RIFF&quot;</span><span class="operator">)</span><span class="operator">;</span>
    <span class="keyword">Возврат</span><span class="operator">;</span>
<span class="keyword">КонецЕсли</span><span class="operator">;</span>
<span class="keyword">Если</span> ТипФайла <span class="operator">=</span> <span class="string">&quot;WAVE&quot;</span> <span class="keyword">Тогда</span>
    Сообщить<span class="operator">(</span><span class="string">&quot;Это WAV-файл с данными, размером &quot;</span> <span class="operator">+</span> РазмерДанных <span class="operator">+</span> <span class="string">&quot; байт&quot;</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">Иначе</span>
    Сообщить<span class="operator">(</span><span class="string">&quot;Это не WAV-файл&quot;</span><span class="operator">)</span><span class="operator">;</span>
    <span class="keyword">Возврат</span><span class="operator">;</span>
<span class="keyword">КонецЕсли</span><span class="operator">;</span></pre>

<p class="MsoNormalCxSpFirst">Рассмотрим
пример более подробно.</p>

<p class="MsoNormalCxSpMiddle">Вначале
открывается файл, имя которого содержится в переменной <span class="Term">ИмяФайла</span>, файл
открывается для чтения (<span class="Term">РежимОткрытияФайла.Открыть</span>), из файла будут
только читать (<span class="Term">ДоступКФайлу.Чтение</span>) и для чтения будет
использоваться буфер размером 16 байт.</p>

<p class="MsoNormalCxSpLast">Затем
формируется поток, предназначенный для чтения данных, который будет иметь
порядок следования байтов «младший-старший» для данных типа <span class="Term">Число</span>. Затем из
получившегося потока считывается 4 символа ASCII, 32-разрядное целое и еще 4
символа ASCII. Получившиеся данные анализируются, и по результатам анализа
принимается решение о том, является выбранный файл .wav-файлом или нет.</p>

<a id="TI000001828" class="bookmark" name="issogl2_16.3.3_запись_двоичных_данных"><h3>16.3.3. Запись двоичных данных</h3></a>

<p class="MsoNormal">Запись
двоичных данных в файл, в простейшем случае, выполняется следующим образом:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">Запись <span class="operator">=</span> <span class="keyword">Новый</span> ЗаписьДанных<span class="operator">(</span>ИмяФайла<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">Для</span> Индекс<span class="operator">=</span><span class="number">0</span> <span class="keyword">По</span> <span class="number">255</span> <span class="keyword">Цикл</span>
    Запись<span class="operator">.</span>ЗаписатьБайт<span class="operator">(</span>Индекс<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">КонецЦикла</span><span class="operator">;</span>
Запись<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormalCxSpFirst">Данный
пример выполняет запись в файл последовательности байтов от 0 до 255 (0xFF в
16-ричной системе). Это самый простой вариант записи.</p>

<p class="MsoNormalCxSpLast">Также
можно использовать способ, аналогичный способу чтения, рассмотренному в
предыдущем примере, когда получается файловый поток и в этот файловый поток
выполняется запись данных.</p>

<a id="TI000001829" class="bookmark" name="issogl2_16.3.4_работа_с_буфером_двоичных_данных"><h3>16.3.4. Работа с буфером двоичных данных</h3></a>

<p class="MsoNormalCxSpFirst">Как
уже было сказано выше, буфер двоичных данных предоставляет удобный способ по
манипуляции фрагментами двоичных данных. Поддерживается не только чтение
данных, но и запись.</p>

<p class="MsoNormalCxSpLast">В
качестве примера будет рассмотрен разбор заголовка RIFF-файла из примера чтения
данных (см. <a href="#_ref446689693">здесь</a>). Для построения примера будут использованы ровно та
же информация о формате файла. Таким образом, необходимо прочитать из исходного
файла буфер размером с заголовок файла. Заголовок состоит из трех 4-байтовых
полей. Таким образом, необходимо прочитать 12 байт.</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">Буфер <span class="operator">=</span> <span class="keyword">Новый</span> БуферДвоичныхДанных<span class="operator">(</span><span class="number">12</span><span class="operator">)</span><span class="operator">;</span>
Файл <span class="operator">=</span> ФайловыеПотоки<span class="operator">.</span>Открыть<span class="operator">(</span>КаталогВременныхФайлов<span class="operator">(</span><span class="operator">)</span> <span class="operator">+</span> <span class="string">&quot;Windows Logon.wav&quot;</span><span class="operator">,</span> РежимОткрытияФайла<span class="operator">.</span>Открыть<span class="operator">,</span> ДоступКФайлу<span class="operator">.</span>Чтение<span class="operator">)</span><span class="operator">;</span>
Файл<span class="operator">.</span>Прочитать<span class="operator">(</span>Буфер<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">12</span><span class="operator">)</span><span class="operator">;</span>
Размер <span class="operator">=</span> Буфер<span class="operator">.</span>ПрочитатьЦелое32<span class="operator">(</span><span class="number">4</span><span class="operator">)</span><span class="operator">;</span>
ПотокСтроки <span class="operator">=</span> <span class="keyword">Новый</span> ПотокВПамяти<span class="operator">(</span>Буфер<span class="operator">)</span><span class="operator">;</span>
ПотокСтроки<span class="operator">.</span><span class="keyword">Перейти</span><span class="operator">(</span><span class="number">0</span><span class="operator">,</span> ПозицияВПотоке<span class="operator">.</span>Начало<span class="operator">)</span><span class="operator">;</span>
ЧтениеСтроки <span class="operator">=</span> <span class="keyword">Новый</span> ЧтениеДанных<span class="operator">(</span>ПотокСтроки<span class="operator">)</span><span class="operator">;</span>
ФорматФайла <span class="operator">=</span> ЧтениеСтроки<span class="operator">.</span>ПрочитатьСимволы<span class="operator">(</span><span class="number">4</span><span class="operator">,</span> <span class="string">&quot;windows-1251&quot;</span><span class="operator">)</span><span class="operator">;</span>
ЧтениеСтроки<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
ПотокСтроки<span class="operator">.</span><span class="keyword">Перейти</span><span class="operator">(</span><span class="number">8</span><span class="operator">,</span> ПозицияВПотоке<span class="operator">.</span>Начало<span class="operator">)</span><span class="operator">;</span>
ЧтениеСтроки <span class="operator">=</span> <span class="keyword">Новый</span> ЧтениеДанных<span class="operator">(</span>ПотокСтроки<span class="operator">)</span><span class="operator">;</span>
ТипФайла <span class="operator">=</span> ЧтениеСтроки<span class="operator">.</span>ПрочитатьСимволы<span class="operator">(</span><span class="number">4</span><span class="operator">,</span> <span class="string">&quot;windows-1251&quot;</span><span class="operator">)</span><span class="operator">;</span>
ЧтениеСтроки<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormalCxSpFirst">Процесс
получения данных в буфер двоичных данных не представляет из себя ничего
особенного. Дальнейшие операции требуют некоторых комментариев. Чтение чисел
любой поддерживаемой разрядности возможно из любой позиции буфера. В данном
примере <span class="Term">Буфер.ПрочитатьЦелое32(4);</span> означает чтение
32-разрядного целого числа, начиная с 4 байта буфера. Таким образом, если
требуется прочитать несколько чисел, расположенных в разных местах буфера, это
можно сделать без прямого позиционирования в этом буфере.</p>

<p class="MsoNormalCxSpMiddle">Чтение
строки, однако, не поддерживается буфером двоичных данных. Поэтому следует
воспользоваться объектом, который это позволяет сделать: <span class="Term">ЧтениеДанных</span>.
Объект <span class="Term">ЧтениеДанных</span> не может быть создан на основании
буфера двоичных данных. Но на основании буфера двоичных данных можно создать
поток, который является универсальным посредником между физическим местом
хранения информации (файл, буфер двоичных данных) и высокоуровневым объектом,
позволяющим работать с этими данными.</p>

<p class="MsoNormalCxSpLast">Когда
создается объект <span class="Term">ЧтениеДанных</span> на основании какого-либо потока,
он начинает читать данные с той позиции, которая в данный момент установлена в
потоке. Поэтому в примере вначале происходит установка позиции в потоке, а
потом создается объект <span class="Term">ЧтениеДанных</span> и выполняется чтение нужного
количества символов. Подробное описание разницы между числом байтов и символов
при чтении строк см. <a href="#_ref448246900">здесь</a>.</p>

<a name="_ref448246900"></a><a name="_ref468709773"></a><a id="TI000001885" class="bookmark" name="issogl2_16.3.5_значения_в_двоичной_и_шестнадцатеричной_системах_и_логические_операции"><h3>16.3.5. Значения в двоичной и шестнадцатеричной системах и логические операции</h3></a>

<p class="MsoNormal">При работе с различными бинарными форматами
достаточно сильно распространены так называемые «магические числа» –
константы или битовые маски. Такие магические числа можно перевести в
десятичные числа, но такое преобразование повышает вероятность ошибок и менее
наглядно. Для того чтобы упростить работы с такими магическими числами,
существуют функции глобального контекста <span class="Term">ЧислоИзШестнадцатеричнойСтроки()</span>
и <span class="Term">ЧислоИзДвоичнойСтроки()</span>.</p>

<p class="Lang-subheader">Пример:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">МаскаСтаршегоБита <span class="operator">=</span> ЧислоИзДвоичнойСтроки<span class="operator">(</span><span class="string">&quot;0b10000000&quot;</span><span class="operator">)</span><span class="operator">;</span>
НаборПараметров <span class="operator">=</span> ЧислоИзШестнадцатеричнойСтроки<span class="operator">(</span><span class="string">&quot;0x79E&quot;</span><span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">Также система предоставляет возможность
выполнять логические операции с буферами двоичных данных. Поддерживаются
следующие операции:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
логическое «И» (метод <span class="Term">ЗаписатьПобитовоеИ()</span>);</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
логическое «ИЛИ» (метод <span class="Term">ЗаписатьПобитовоеИли()</span>);</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
логическое «исключающее ИЛИ» (метод <span class="Term">ЗаписатьПобитовоеИсключающееИли()</span>);</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
логическое «И НЕ» (обратная операция к
логическому «И», метод <span class="Term">ЗаписатьПобитовоеИНе()</span>);</p>

<p class="MsoListBulletCxSpLast">&#9679; 
инверсия (метод <span class="Term">Инвертировать()</span>).</p>

<p class="MsoNormal">С помощью данных методов можно выполнять
различные логические операции над данными, включая проверки установки конкретных
битов.</p>

<a name="_ref468710005"></a><a name="_ref468710004"></a><a id="TI000001830" class="bookmark" name="issogl2_16.3.6_особенности_использования"><h3>16.3.6. Особенности использования</h3></a>

<p class="Lang-parameter">Работа
со строками</p>

<p class="MsoNormalCxSpFirst">При
использовании двоичных данных следует учитывать особенности работы с данными
типа <span class="Term">Строка</span>. Особенность заключается в том, что
длина строки, которую возвращает функция глобального контекста <span class="Term">СтрДлина()</span>,
измеряется в символах. В символах же следует указывать размеры
читаемых/записываемых данных в методах записи/чтения строк в объектах работы с
двоичными данными (<span class="Term">ПрочитатьСимволы()</span>, <span class="Term">ПрочитатьСтроку()</span>,
<span class="Term">ЗаписатьСимволы()</span>, <span class="Term">ЗаписатьСтроку()</span>).
При этом не существует однозначного варианта преобразования длины строки в
символах в аналогичный параметр в байтах. В зависимости от содержимого строки и
кодировки, это соотношение будет разным. Например, в кодировке UTF-8 один
символ может занимать от одного до шести байт. Поэтому при работе с какими-либо
структурами данных, в состав которых входят строки переменной длины, следует
четко понимать, в каких единицах выражены длины строк.</p>

<p class="MsoNormalCxSpMiddle">В
том случае, когда необходимо выполнить конвертацию строки в байтовый набор и
обратно, следует воспользоваться специальными методами <span class="Term">ПолучитьДвоичныеДанныеИзСтроки()</span>/<span class="Term">ПолучитьБуферДвоичныхДанныхИзСтроки()</span> и
обратных к ним <span class="Term">ПолучитьСтрокуИзДвоичныхДанных()</span>/<span class="Term">ПолучитьСтрокуИзБуфераДвоичныхДанных()</span>.</p>

<p class="MsoNormalCxSpMiddle">Данные
методы позволяют указать кодировку строки и необходимость использования BOM (Byte
Order Mark, маркер последовательности байт для кодировки Unicode). При
конвертации строки в байтовый набор, размер получившейся строки можно получить
через стандартный интерфейс определения размера получившегося объекта (<span class="Term">ДвоичныеДанные.Размер()</span> или <span class="Term">БуферДвоичныхДанных.Размер</span>).</p>

<p class="MsoNormalCxSpLast">Таким
образом, получить двоичные данные из строки можно следующим образом:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
Данные = ПолучитьДвоичныеДанныеИзСтроки(&quot;Пример строки для конвертации&quot;, &quot;UTF-8&quot;, Ложь);
РазмерСтрокиВБайтах = Данные.Размер();
</pre>

<p class="MsoNormal">Обратная
операция выполняется следующим образом:</p>

<p class="MsoListNumberCxSpFirst">1.  Из
потока чтения выполняется получение буфера двоичных данных требуемого размера.</p>

<p class="MsoListNumberCxSpLast">2. 
Получившийся буфер двоичных данных преобразуется
в строку.</p>

<p class="MsoNormal">На
встроенном языке данная операция будет выглядеть следующим образом:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev"><span class="comment">// ПотокЧтения – существующий поток чтения</span>
Буфер <span class="operator">=</span> ПотокЧтения<span class="operator">.</span>ПрочитатьВБуферДвоичныхДанных<span class="operator">(</span>ДлинаСтрокиВБайтах<span class="operator">)</span><span class="operator">;</span>
СчитаннаяСтрока <span class="operator">=</span> ПолучитьСтрокуИзБуфераДвоичныхДанных<span class="operator">(</span>Буфер<span class="operator">)</span><span class="operator">;</span> </pre>

<p class="Lang-parameter">Совместное
использование разных объектов</p>

<p class="MsoNormal">Не
рекомендуется одновременное использование объектов <span class="Term">ЧтениеДанных</span>/<span class="Term">ЗаписьДанных</span> и
потоковых объектов. Если между двумя последовательными операциями чтения из <span class="Term">ЧтениеДанных</span> или
двумя последовательными операциями записи в <span class="Term">ЗаписьДанных</span>
происходит изменение позиции в потоке, с которым работают объекты <span class="Term">ЧтениеДанных</span>/<span class="Term">ЗаписьДанных</span> –
генерируется исключение. Так, следующий пример демонстрирует корректное
изменение позиции в потоке при записи данных в поток:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">Поток <span class="operator">=</span> <span class="keyword">Новый</span> ПотокВПамяти<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
ЗаписьДанных <span class="operator">=</span> <span class="keyword">Новый</span> ЗаписьДанных<span class="operator">(</span>Поток<span class="operator">)</span><span class="operator">;</span>
ЗаписьДанных<span class="operator">.</span>ЗаписатьСтроку<span class="operator">(</span><span class="string">&quot;Привет, мир!&quot;</span><span class="operator">)</span><span class="operator">;</span>
ЗаписьДанных<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
Поток<span class="operator">.</span><span class="keyword">Перейти</span><span class="operator">(</span><span class="number">0</span><span class="operator">,</span> ПозицияВПотоке<span class="operator">.</span>Начало<span class="operator">)</span><span class="operator">;</span>
ЗаписьДанных <span class="operator">=</span> <span class="keyword">Новый</span> ЗаписьДанных<span class="operator">(</span>Поток<span class="operator">)</span><span class="operator">;</span>
ЗаписьДанных<span class="operator">.</span>ЗаписатьСтроку<span class="operator">(</span><span class="string">&quot;Пока!&quot;</span><span class="operator">)</span><span class="operator">;</span>
ЗаписьДанных<span class="operator">.</span>Закрыть<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormal">Следующий
пример приведет к возникновению исключения:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
Поток = Новый ПотокВПамяти();
ЗаписьДанных = Новый ЗаписьДанных(Поток);
ЗаписьДанных.ЗаписатьСтроку(&quot;Привет, мир!&quot;);
Поток.Перейти(0, ПозицияВПотоке.Начало);
// В следующей строке будет сгенернировано исключение
ЗаписьДанных.ЗаписатьСтроку(&quot;Пока!&quot;);
</pre>

<p class="MsoNormal">В
тоже время, возможны ситуации, когда поведение системы будет некорректно, но
никаких ошибок формироваться не будет:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_res">
Поток = ПолучитьПоток();
ЧтениеДанных = Новый ЧтениеДанных(Поток);
ТестоваяСтрока = ЧтениеДанных.Прочитать();
ИсходнаяПозиция = Поток.ТекущаяПозиция();
ЗаписьДанных = Новый ЗаписьДанных(Поток);
ЗаписьДанных.ЗаписатьСтроку(&quot;Неожиданная строка&quot;);
ЗаписьДанных.Закрыть();
Поток.Перейти(ИсходнаяПозиция, ПозицияВПотоке.Начало);
// В общем случае невозможно определить, какое значение будет помещено в переменную ТестоваяСтрока2
ТестоваяСтрока2 = ЧтениеДанных.ПрочитатьСтроку();
</pre>

<p class="MsoNormalCxSpFirst">Описанное
в данном разделе поведение вызвано тем, что объекты <span class="Term">ЧтениеДанных</span>/<span class="Term">ЗаписьДанных</span>
используют собственные буфера при работе с потоком. В результате фактическая
позиция потока отличается от логической позиции, которая сформирована как
результат совершенных операций.</p>

<p class="MsoNormalCxSpLast">Также
не поддерживается одновременное использование объектов <span class="Term">ЧтениеДанных</span> и <span class="Term">ЗаписьДанных</span>,
которые используют для своей работы один поток.</p>

<p class="Lang-parameter">Упрощение
побитовых операций</p>

<p class="MsoNormalCxSpFirst">Достаточно
распространенной операцией является проверка и установка какого-либо разряда в
наборе данных, который, например, хранит набор булевых флагов. Напрямую такие
операции системой не поддерживаются. Однако система предоставляет все
возможности для реализации таких возможностей. Следует понимать, что так-как
система типов «1С:Предприятия» не предполагает наличие специализированных без
знаковых типов ограниченной разрядности, все дальнейшие методы опираются на
предположение о том, что передаются целые, без знаковые числа.</p>

<p class="MsoNormalCxSpLast">Для
реализации такой операции потребуются две вспомогательные функции, первая из
которых будет преобразовывать переданное число в буфер двоичных данных
необходимого размера, а вторая будет выполнять обратную операцию – из
буфера двоичных данных формировать значение типа <span class="Term">Число</span>.</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev"><span class="keyword">Функция</span> РазбитьЧислоНаБайты<span class="operator">(</span><span class="keyword">Знач</span> Число<span class="operator">,</span> ЧислоБайт <span class="operator">=</span> <span class="number">0</span><span class="operator">,</span> Заполнитель <span class="operator">=</span> <span class="number">0</span><span class="operator">)</span>
    <span class="comment">// разбиваем переданное число на байты</span>
    Число <span class="operator">=</span> Цел<span class="operator">(</span>Число<span class="operator">)</span><span class="operator">;</span>
    ПоБайтныйМассив <span class="operator">=</span> <span class="keyword">Новый</span> Массив<span class="operator">;</span>
    <span class="keyword">Пока</span> Число <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">Цикл</span>
        ПоБайтныйМассив<span class="operator">.</span>Добавить<span class="operator">(</span>Число % <span class="number">256</span><span class="operator">)</span><span class="operator">;</span>
        Число <span class="operator">=</span> Цел<span class="operator">(</span>Число <span class="operator">/</span> <span class="number">256</span><span class="operator">)</span><span class="operator">;</span>
    <span class="keyword">КонецЦикла</span><span class="operator">;</span>
    <span class="comment">// если требуется какая-то конкретная разрядность числа – здесь сделаем это</span>
    <span class="keyword">Если</span> ЧислоБайт <span class="operator">&lt;</span><span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">Тогда</span>
        <span class="keyword">Если</span> ЧислоБайт <span class="operator">&lt;</span> ПоБайтныйМассив<span class="operator">.</span>Количество<span class="operator">(</span><span class="operator">)</span> <span class="keyword">Тогда</span>
            <span class="comment">// усечем результат до заданного размера</span>
            <span class="keyword">Пока</span> ПоБайтныйМассив<span class="operator">.</span>Количество<span class="operator">(</span><span class="operator">)</span> <span class="operator">&gt;</span> ЧислоБайт <span class="keyword">Цикл</span>
                ПоБайтныйМассив<span class="operator">.</span>Удалить<span class="operator">(</span>ЧислоБайт<span class="operator">)</span><span class="operator">;</span>
            <span class="keyword">КонецЦикла</span><span class="operator">;</span>
        <span class="keyword">Иначе</span>
            <span class="comment">// добавим старшие байты из заполнителя</span>
            Разница <span class="operator">=</span> ЧислоБайт – ПоБайтныйМассив<span class="operator">.</span>Количество<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
            <span class="keyword">Пока</span> Разница <span class="operator">&lt;</span><span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">Цикл</span>
                ПоБайтныйМассив<span class="operator">.</span>Добавить<span class="operator">(</span>Заполнитель<span class="operator">)</span><span class="operator">;</span>
                Разница <span class="operator">=</span> Разница – <span class="number">1</span><span class="operator">;</span>
            <span class="keyword">КонецЦикла</span><span class="operator">;</span>
        <span class="keyword">КонецЕсли</span><span class="operator">;</span>
    <span class="keyword">КонецЕсли</span><span class="operator">;</span>
    БуферДвоичныхДанных <span class="operator">=</span> <span class="keyword">Новый</span> БуферДвоичныхДанных<span class="operator">(</span>ПоБайтныйМассив<span class="operator">.</span>Количество<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
    <span class="keyword">Для</span> Счетчик <span class="operator">=</span> <span class="number">0</span> <span class="keyword">По</span> ПоБайтныйМассив<span class="operator">.</span>Количество<span class="operator">(</span><span class="operator">)</span><span class="operator">-</span><span class="number">1</span> <span class="keyword">Цикл</span>
        БуферДвоичныхДанных<span class="operator">[</span>Счетчик<span class="operator">]</span> <span class="operator">=</span> ПоБайтныйМассив<span class="operator">[</span>Счетчик<span class="operator">]</span><span class="operator">;</span>
    <span class="keyword">КонецЦикла</span><span class="operator">;</span>
    <span class="keyword">Возврат</span> БуферДвоичныхДанных<span class="operator">;</span>
<span class="keyword">КонецФункции</span>
<span class="keyword">Функция</span> СобратьЧислоИзБайтов<span class="operator">(</span>БуферДвоичныхДанных<span class="operator">)</span>
    Результат <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
    Позиция <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
    <span class="keyword">Для</span> <span class="keyword">каждого</span> Байт <span class="keyword">Из</span> БуферДвоичныхДанных <span class="keyword">Цикл</span>
        Результат <span class="operator">=</span> Результат <span class="operator">+</span> <span class="operator">?</span><span class="operator">(</span>Позиция <span class="operator">=</span> <span class="number">0</span><span class="operator">,</span> БуферДвоичныхДанных<span class="operator">[</span>Позиция<span class="operator">]</span><span class="operator">,</span> БуферДвоичныхДанных<span class="operator">[</span>Позиция<span class="operator">]</span> <span class="operator">*</span> Pow<span class="operator">(</span><span class="number">256</span><span class="operator">,</span> Позиция<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
        Позиция <span class="operator">=</span> Позиция <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
    <span class="keyword">КонецЦикла</span><span class="operator">;</span>
    <span class="keyword">Возврат</span> Результат<span class="operator">;</span>
<span class="keyword">КонецФункции</span></pre>

<p class="MsoNormalCxSpFirst">Данный
пример не учитывает порядок следования байт в буфере. Самое младшее значение
всегда располагается в самом младшем байте формируемого буфера двоичных данных.
Это предположение одинаково для обеих вспомогательных функций.</p>

<p class="MsoNormalCxSpLast">Тогда
операция логического «И» для двух числе будет выглядеть следующим образом:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev"><span class="keyword">Функция</span> ЛогическоеИ<span class="operator">(</span><span class="keyword">Знач</span> Операнд1<span class="operator">,</span> <span class="keyword">Знач</span> Операнд2<span class="operator">,</span> <span class="keyword">Знач</span> ДлинаОперандов <span class="operator">=</span> <span class="number">0</span><span class="operator">)</span>
    Буфер1 <span class="operator">=</span> РазбитьЧислоНаБайты<span class="operator">(</span>Операнд1<span class="operator">)</span><span class="operator">;</span>
    ДлинаОперандов <span class="operator">=</span> <span class="operator">?</span><span class="operator">(</span>ДлинаОперандов <span class="operator">=</span> <span class="number">0</span><span class="operator">,</span> Буфер1<span class="operator">.</span>Размер<span class="operator">,</span> ДлинаОперандов<span class="operator">)</span><span class="operator">;</span>
    Буфер2 <span class="operator">=</span> РазбитьЧислоНаБайты<span class="operator">(</span>Операнд2<span class="operator">,</span> ДлинаОперандов<span class="operator">)</span><span class="operator">;</span>
    Буфер1<span class="operator">.</span>ЗаписатьПобитовоеИ<span class="operator">(</span><span class="number">0</span><span class="operator">,</span> Буфер2<span class="operator">,</span> ДлинаОперандов<span class="operator">)</span><span class="operator">;</span>
    Результат <span class="operator">=</span> СобратьЧислоИзБайтов<span class="operator">(</span>Буфер1<span class="operator">)</span><span class="operator">;</span>
    <span class="keyword">Возврат</span> Результат<span class="operator">;</span>
<span class="keyword">КонецФункции</span></pre>

<p class="MsoNormalCxSpFirst">В
данном случае принимается, что размер второго операнда в операции всегда равен
размеру первого операнда.</p>

<p class="MsoNormalCxSpLast">Собственно
использование данной функции (<span class="Term">ЛогическоеИ()</span>)
можно проиллюстрировать следующим примером:</p>

<a class="copy_source" href="#_top" onClick="return false">Копировать в буфер обмена</a>
<pre class="src_dev">ЧТЕНИЕ    <span class="operator">=</span> ЧислоИзДвоичнойСтроки<span class="operator">(</span><span class="string">&quot;0b00000001&quot;</span><span class="operator">)</span><span class="operator">;</span>
СОЗДАНИЕ  <span class="operator">=</span> ЧислоИзДвоичнойСтроки<span class="operator">(</span><span class="string">&quot;0b00000010&quot;</span><span class="operator">)</span><span class="operator">;</span>
ИЗМЕНЕНИЕ <span class="operator">=</span> ЧислоИзДвоичнойСтроки<span class="operator">(</span><span class="string">&quot;0b00000100&quot;</span><span class="operator">)</span><span class="operator">;</span>
УДАЛЕНИЕ  <span class="operator">=</span> ЧислоИзДвоичнойСтроки<span class="operator">(</span><span class="string">&quot;0b00001000&quot;</span><span class="operator">)</span><span class="operator">;</span>
ФлагиДоступа <span class="operator">=</span> ЧислоИзДвоичнойСтроки<span class="operator">(</span><span class="string">&quot;0b00001110&quot;</span><span class="operator">)</span><span class="operator">;</span>
ЧтениеВозможно <span class="operator">=</span> ЛогическоеИ<span class="operator">(</span>ФлагиДоступа<span class="operator">,</span> ЧТЕНИЕ<span class="operator">)</span><span class="operator">;</span>
ЗаписьВозможна <span class="operator">=</span> ЛогическоеИ<span class="operator">(</span>ФлагиДоступа<span class="operator">,</span> СОЗДАНИЕ<span class="operator">+</span>ИЗМЕНЕНИЕ<span class="operator">)</span><span class="operator">;</span>
ПолныйДоступ <span class="operator">=</span> ЛогическоеИ<span class="operator">(</span>ФлагиДоступа<span class="operator">,</span> СОЗДАНИЕ<span class="operator">+</span>ИЗМЕНЕНИЕ<span class="operator">+</span>ЧТЕНИЕ<span class="operator">+</span>УДАЛЕНИЕ<span class="operator">)</span><span class="operator">;</span></pre>

<p class="MsoNormalCxSpFirst">В
данном примере рассматривается некий байт, который содержит флаги, определяющие
возможности работы с предполагаемым файлом. Каждый флаг определяется своей
маской (переменные <span class="Term">ЧТЕНИЕ</span>,
<span class="Term">СОЗДАНИЕ</span>,
<span class="Term">ИЗМЕНЕНИЕ</span>,
<span class="Term">УДАЛЕНИЕ</span>).
Проверка флага осуществляется просто: если результат функции <span class="Term">ЛогическоеИ()</span> не равен сумме проверяемых
флагов – значит, что флаги, которые необходимо проверить, установлены не
все. Если результат функции равен сумме проверяемых флагов – значит все
проверяемые флаги установлены. В упрощенном случае проверка одного флага вернет
значение 0, если флаг не установлен и собственно значение флага – если
флаг установлен.</p>

<p class="MsoNormalCxSpLast">В
вышеприведенном примере для флагов <span class="Term">ФлагиДоступа</span>:</p>

<p class="MsoListBulletCxSpFirst">&#9679; 
Чтение недоступно. Значение переменной <span class="Term">ЧтениеДоступно</span> равно 0.</p>

<p class="MsoListBulletCxSpMiddle">&#9679; 
Запись возможна. Значение переменной <span class="Term">ЗаписьВозможна</span> равно 6 (сумма флагов <span class="Term">СОЗДАНИЕ</span> и <span class="Term">ИЗМЕНЕНИЕ</span>).</p>

<p class="MsoListBulletCxSpLast">&#9679; 
Полный доступ невозможен. Значение переменно <span class="Term">ПолныйДоступ</span> равно 15 (сумма всех описанных
флагов, за вычетом недоступного флага <span class="Term">ЧТЕНИЕ</span>).</p>

<p class="MsoNormal">Аналогично
методу <span class="Term">ЛогическоеИ()</span>
можно выполнить и остальные функции побитовой работы с данными.</p>		<script type="text/javascript">listenCopy('zeroclipboard.swf');</script>
	</body>
</html>